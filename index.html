<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Cosmic Scale Riemann Hypothesis Tester</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            text-align: center;
            color: #a0a0a0;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(40, 40, 60, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #4ecdc4;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #c0c0c0;
        }
        
        input, select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            box-sizing: border-box;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.1);
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .preset-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px 12px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            margin-top: 0;
            width: auto;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .results {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .results h3 {
            margin-top: 0;
            color: #4ecdc4;
            border-bottom: 2px solid #4ecdc4;
            padding-bottom: 10px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(20, 20, 30, 0.5);
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
        }
        
        .metric-label {
            font-weight: 500;
            color: #c0c0c0;
        }
        
        .metric-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
        }
        
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .status.computing {
            background: rgba(255, 243, 205, 0.2);
            color: #feca57;
            border: 1px solid #feca57;
        }
        
        .status.complete {
            background: rgba(209, 236, 241, 0.2);
            color: #4ecdc4;
            border: 1px solid #4ecdc4;
        }

        .cosmic-status {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border: 2px solid;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-cosmic {
            background: linear-gradient(45deg, rgba(255, 107, 107, 0.2), rgba(238, 90, 82, 0.2));
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .status-legendary {
            background: linear-gradient(45deg, rgba(255, 154, 86, 0.2), rgba(255, 123, 123, 0.2));
            border-color: #ff9a56;
            color: #ff9a56;
        }

        .status-mythical {
            background: linear-gradient(45deg, rgba(78, 205, 196, 0.2), rgba(68, 160, 141, 0.2));
            border-color: #4ecdc4;
            color: #4ecdc4;
        }

        .status-excellent {
            background: linear-gradient(45deg, rgba(150, 206, 180, 0.2), rgba(68, 160, 141, 0.2));
            border-color: #96ceb4;
            color: #96ceb4;
        }

        .status-good {
            background: linear-gradient(45deg, rgba(254, 202, 87, 0.2), rgba(255, 159, 67, 0.2));
            border-color: #feca57;
            color: #feca57;
        }

        .status-high {
            background: linear-gradient(45deg, rgba(255, 154, 86, 0.2), rgba(255, 107, 107, 0.2));
            border-color: #ff9a56;
            color: #ff9a56;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .visualization-item {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .visualization-item h4 {
            color: #4ecdc4;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        canvas {
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        
        .computing-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #4ecdc4;
            border-radius: 50%;
            animation: pulse 1s infinite;
            margin-left: 5px;
        }
        
        .chart-info {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #4ecdc4;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            min-height: 60px;
        }
        
        .chart-info-title {
            color: #4ecdc4;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .chart-tooltip {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #4ecdc4;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 200px;
        }
        
        .theory-box {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1));
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #4ecdc4;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        
        .theory-box h4 {
            margin-top: 0;
            color: #4ecdc4;
        }

        .detailed-results {
            margin-top: 20px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .results-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #c0c0c0;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 0;
            width: auto;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border-color: #4ecdc4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .top-results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .top-results-table th,
        .top-results-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        .top-results-table th {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        .insights {
            background: rgba(78, 205, 196, 0.1);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #4ecdc4;
        }

        .heatmap-container {
            text-align: center;
            margin: 20px 0;
        }

        .heatmap-legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .statistics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(20, 20, 30, 0.8);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #4ecdc4;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #45b7d1, #96ceb4);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin-top: 0;
            width: auto;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(69, 183, 209, 0.4);
        }
        
        @keyframes computing {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .computing button {
            animation: computing 2s infinite;
        }

        small {
            color: #a0a0a0;
            font-size: 12px;
            display: block;
            margin-top: 5px;
        }

        .advanced-options {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .performance-indicator {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid;
        }

        .perf-excellent {
            background: rgba(78, 205, 196, 0.1);
            border-color: #4ecdc4;
            color: #4ecdc4;
        }

        .perf-good {
            background: rgba(150, 206, 180, 0.1);
            border-color: #96ceb4;
            color: #96ceb4;
        }

        .perf-warning {
            background: rgba(254, 202, 87, 0.1);
            border-color: #feca57;
            color: #feca57;
        }

        .perf-danger {
            background: rgba(255, 107, 107, 0.1);
            border-color: #ff6b6b;
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåå Enhanced Cosmic Scale Riemann Hypothesis Tester</h1>
        <p class="subtitle">Advanced Browser-Based Computational Testing with Comprehensive Analysis - Up to 100 Million Points</p>
        
        <div class="theory-box">
            <h4>The Riemann Hypothesis - One of Mathematics' Greatest Mysteries</h4>
            <p>The Riemann Hypothesis, proposed by Bernhard Riemann in 1859, is one of the most important unsolved problems in mathematics. It concerns the distribution of prime numbers and has profound implications for number theory, cryptography, and our understanding of mathematical patterns.</p>
            
            <div class="math-formula">
                S(N,Œ±) = Œ£<sub>n‚â§N</sub> Œº(n) ¬∑ e<sup>2œÄinŒ±</sup>
            <div class="theory-box">
            <h4>üåÄ The Riemann Zeta Function and Its Critical Zeros</h4>
            
            <div style="background: rgba(69, 183, 209, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h5 style="color: #45b7d1; margin-top: 0;">The Zeta Function Defined</h5>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 16px; margin: 15px 0;">
                    Œ∂(s) = Œ£<sub>n=1</sub><sup>‚àû</sup> 1/n<sup>s</sup> = 1 + 1/2<sup>s</sup> + 1/3<sup>s</sup> + 1/4<sup>s</sup> + ...
                <div class="theory-box">
            <h4>Enhanced by Wessen Getachew</h4>
            <p><strong>Creator:</strong> Wessen Getachew (<a href="https://twitter.com/7dview" target="_blank" style="color: #4ecdc4;">@7dview</a>)</p>
            <p><strong>Mathematical Framework:</strong> Based on classical work by Davenport, Halberstam, Montgomery, and modern computational number theory</p>
            <p><strong>Implementation:</strong> Advanced JavaScript algorithms with comprehensive visualization and interactive analysis for browser-based scientific computing</p>
            <p><strong>Special thanks to:</strong> The open mathematics community, Andrew Odlyzko's computational work, Xavier Gourdon's large-scale verifications, and all researchers who have contributed to our understanding of the Riemann Hypothesis</p>
        </div>
                <p style="margin: 10px 0; font-size: 13px;">Where <strong>s = œÉ + it</strong> is a complex number with real part œÉ and imaginary part t</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">For Real s > 1:</h6>
                        <p style="margin: 0; font-size: 12px;">Series converges absolutely<br>Œ∂(2) = œÄ¬≤/6, Œ∂(4) = œÄ‚Å¥/90</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">For œÉ < 1:</h6>
                        <p style="margin: 0; font-size: 12px;">Analytic continuation needed<br>Functional equation relates Œ∂(s) to Œ∂(1-s)</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">The Critical Strip:</h6>
                        <p style="margin: 0; font-size: 12px;">0 < œÉ < 1<br>Where non-trivial zeros live</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">üéØ The Critical Zeros and Prime Connection</h5>
            
            <div style="background: rgba(255, 107, 107, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #ff6b6b; margin-top: 0;">Euler's Product Formula (The Bridge to Primes)</h6>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 14px; margin: 10px 0;">
                    Œ∂(s) = Œ†<sub>p prime</sub> 1/(1 - 1/p<sup>s</sup>)
                </div>
                <p style="margin: 10px 0; font-size: 13px;"><strong>This is why Œ∂(s) encodes all information about primes!</strong> Every prime p contributes a factor to the infinite product.</p>
            </div>
            
            <div style="background: rgba(254, 202, 87, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #feca57; margin-top: 0;">The Explicit Formula (How Zeros Control Primes)</h6>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 14px; margin: 10px 0;">
                    œÄ(x) = Li(x) - Œ£<sub>œÅ</sub> Li(x<sup>œÅ</sup>) + O(x<sup>1/2</sup>)
                </div>
                <p style="margin: 10px 0; font-size: 13px;">Where œÅ = 1/2 + it are the <strong>critical zeros</strong>. Each zero œÅ contributes an oscillatory term Li(x<sup>œÅ</sup>) to the prime counting function!</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div>
                        <h7 style="color: #feca57; font-weight: bold;">If RH is True (all zeros on œÉ = 1/2):</h7>
                        <ul style="margin: 5px 0; padding-left: 15px; font-size: 12px;">
                            <li>|œÄ(x) - Li(x)| ‚â™ ‚àöx ln(x)</li>
                            <li>Prime gaps ‚â™ ‚àöp ln(p)</li>
                            <li>Oscillations are "balanced"</li>
                        </ul>
                    </div>
                    <div>
                        <h7 style="color: #ff6b6b; font-weight: bold;">If RH is False (zeros off the line):</h7>
                        <ul style="margin: 5px 0; padding-left: 15px; font-size: 12px;">
                            <li>Larger deviations possible</li>
                            <li>Prime distribution less regular</li>
                            <li>Cryptographic implications</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">üîó How Our M√∂bius Verification Connects to Zeros</h5>
            
            <div style="background: rgba(78, 205, 196, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #4ecdc4; margin-top: 0;">The Deep Connection</h6>
                <p style="margin: 10px 0; font-size: 13px;">Our exponential sums S(N,Œ±) = Œ£ Œº(n)e<sup>2œÄinŒ±</sup> are related to the zeta zeros through:</p>
                
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 13px; margin: 15px 0; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px;">
                    Œ£<sub>n‚â§x</sub> Œº(n) = Œ£<sub>œÅ</sub> x<sup>œÅ</sup>/œÅ Œ∂'(œÅ)/Œ∂(œÅ) + lower order terms
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h7 style="color: #4ecdc4; font-weight: bold;">When |S(N,Œ±)| is small:</h7>
                        <p style="margin: 5px 0; font-size: 12px;">‚Ä¢ Zeros are behaving "as expected"<br>‚Ä¢ Cancellation is working properly<br>‚Ä¢ RH predictions hold</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h7 style="color: #ff6b6b; font-weight: bold;">When |S(N,Œ±)| is large:</h7>
                        <p style="margin: 5px 0; font-size: 12px;">‚Ä¢ Possible resonance effects<br>‚Ä¢ Zero distribution anomalies<br>‚Ä¢ Interesting mathematics!</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">üåê The Complete Picture: All s Values</h5>
            
            <div style="background: linear-gradient(135deg, rgba(150, 206, 180, 0.1), rgba(68, 160, 141, 0.1)); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">üìç Trivial Zeros (s = -2, -4, -6, ...)</h6>
                        <p style="margin: 0; font-size: 12px;">At negative even integers. These come from the functional equation and are well understood. They don't affect prime distribution significantly.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">üéØ Critical Zeros (œÉ = 1/2 + it)</h6>
                        <p style="margin: 0; font-size: 12px;"><strong>The stars of the show!</strong> These control prime distribution. RH says they ALL lie on the critical line œÉ = 1/2.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">üö´ The Critical Strip (0 < œÉ < 1)</h6>
                        <p style="margin: 0; font-size: 12px;">If any non-trivial zeros exist off the line œÉ = 1/2 but in this strip, RH fails and prime behavior becomes less predictable.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">üîÑ Functional Equation</h6>
                        <p style="margin: 0; font-size: 12px;">Œ∂(s) = 2<sup>s</sup>œÄ<sup>s-1</sup>sin(œÄs/2)Œì(1-s)Œ∂(1-s)<br>Relates values at s and 1-s</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">üî¢ Known Zero Statistics</h5>
            
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 12px;">
                <tr style="background: rgba(255,255,255,0.1);">
                    <th style="padding: 8px; border: 1px solid #666;">Height Range</th>
                    <th style="padding: 8px; border: 1px solid #666;">Zeros Computed</th>
                    <th style="padding: 8px; border: 1px solid #666;">All on œÉ = 1/2?</th>
                    <th style="padding: 8px; border: 1px solid #666;">Computational Effort</th>
                </tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 100</td><td style="padding: 6px; border: 1px solid #666;">29</td><td style="padding: 6px; border: 1px solid #666;">‚úÖ Yes</td><td style="padding: 6px; border: 1px solid #666;">By hand (Riemann era)</td></tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 10,000</td><td style="padding: 6px; border: 1px solid #666;">~3,000</td><td style="padding: 6px; border: 1px solid #666;">‚úÖ Yes</td><td style="padding: 6px; border: 1px solid #666;">Early computers</td></tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 10¬π¬≥</td><td style="padding: 6px; border: 1px solid #666;">~10¬π¬≥</td><td style="padding: 6px; border: 1px solid #666;">‚úÖ Yes</td><td style="padding: 6px; border: 1px solid #666;">Modern supercomputers</td></tr>
            </table>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">üéº The Beautiful Harmony</h5>
            
            <div style="background: rgba(69, 183, 209, 0.1); border: 1px solid rgba(69, 183, 209, 0.3); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <p style="margin: 0; font-style: italic; font-size: 14px;"><strong>The zeros of Œ∂(s) are like the "harmonics" of the prime number "symphony."</strong></p>
                
                <ul style="margin: 10px 0; padding-left: 20px; font-size: 13px;">
                    <li><strong>Each zero œÅ = 1/2 + it</strong> contributes an oscillation Li(x<sup>œÅ</sup>) = Li(x<sup>1/2+it</sup>) to the prime counting function</li>
                    <li><strong>The imaginary parts t</strong> determine the "frequencies" of oscillation in prime distribution</li>
                    <li><strong>If all zeros are on œÉ = 1/2,</strong> these oscillations are perfectly balanced and cancel optimally</li>
                    <li><strong>Our M√∂bius verification</strong> checks that this cancellation is working as RH predicts</li>
                </ul>
                
                <div style="text-align: center; margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                    <strong>Every small ratio |S(N,Œ±)|/‚àöN we compute is evidence that the zeros are singing in perfect harmony! üéµ</strong>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">üî¨ What Our Verification Specifically Tests</h5>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 12px;">
                    <h6 style="color: #ff6b6b; margin: 0 0 8px 0;">Direct Zero Impact</h6>
                    <p style="margin: 0; font-size: 12px;">Our sums are directly influenced by zeros with imaginary parts t ‚âà Œ±¬∑N/(2œÄ). We're probing the zero distribution!</p>
                </div>
                
                <div style="background: rgba(254, 202, 87, 0.1); border-left: 4px solid #feca57; padding: 12px;">
                    <h6 style="color: #feca57; margin: 0 0 8px 0;">Cancellation Quality</h6>
                    <p style="margin: 0; font-size: 12px;">Small ratios mean the zeros are creating the precise cancellations needed for RH error bounds.</p>
                </div>
                
                <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 12px;">
                    <h6 style="color: #4ecdc4; margin: 0 0 8px 0;">Statistical Behavior</h6>
                    <p style="margin: 0; font-size: 12px;">The distribution of our results reflects the statistical properties of zeros predicted by random matrix theory.</p>
                </div>
            </div>
            
            <div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.15), rgba(68, 160, 141, 0.15)); border-radius: 10px; padding: 20px; margin: 20px 0; border: 2px solid rgba(78, 205, 196, 0.3);">
                <h6 style="color: #4ecdc4; margin: 0 0 15px 0; text-align: center; font-size: 16px;">üåü The Grand Unification</h6>
                <p style="margin: 0; text-align: center; font-size: 14px; font-style: italic;">Our browser-based M√∂bius verification connects:</p>
                <div style="text-align: center; margin: 15px 0; line-height: 1.8;">
                    <strong>Riemann Zeta Zeros</strong> ‚Üî <strong>Prime Distribution</strong> ‚Üî <strong>M√∂bius Cancellation</strong> ‚Üî <strong>Cryptographic Security</strong>
                </div>
                <p style="margin: 15px 0 0 0; text-align: center; font-size: 13px;">Every test you run explores this magnificent mathematical symphony! üéº</p>
            </div>
        </div>
            
            <p><strong>What we're testing:</strong> Under the Riemann Hypothesis, these M√∂bius exponential sums should satisfy |S(N,Œ±)| = O(‚àöN) uniformly in Œ±. If we find ratios significantly larger than ‚àöN, it could indicate interesting mathematical phenomena or even contradict RH predictions.</p>
            
            <h4>The M√∂bius Function Œº(n)</h4>
            <p>The M√∂bius function is defined as:</p>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li><strong>Œº(n) = 1</strong> if n is a square-free positive integer with an even number of prime factors</li>
                <li><strong>Œº(n) = -1</strong> if n is a square-free positive integer with an odd number of prime factors</li>
                <li><strong>Œº(n) = 0</strong> if n has a squared prime factor</li>
            </ul>
            <p>Examples: Œº(1)=1, Œº(2)=-1, Œº(3)=-1, Œº(4)=0, Œº(6)=1, Œº(12)=0</p>
        </div>
        
        <div class="theory-box">
            <h4>Historical Context & Significance</h4>
            <p><strong>Prime Number Connection:</strong> The hypothesis directly relates to how accurately we can predict the distribution of prime numbers. If true, it provides the best possible bounds for counting primes.</p>
            
            <p><strong>Cryptographic Implications:</strong> Many modern encryption systems rely on the difficulty of factoring large numbers. RH predictions help us understand the security foundations of these systems.</p>
            
            <p><strong>Computational Verification:</strong> The hypothesis has been verified for the first 10<sup>13</sup> zeros, but a general proof remains one of mathematics' greatest challenges.</p>
        </div>
        
        <div class="theory-box">
            <h4>üî¢ What This Tells Us About Prime Numbers</h4>
            
            <div style="background: rgba(78, 205, 196, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h5 style="color: #4ecdc4; margin-top: 0;">The Gauss-Legendre Connection</h5>
                <p><strong>œÄ(x)</strong> = actual count of primes ‚â§ x &nbsp;|&nbsp; <strong>Li(x)</strong> = logarithmic integral ‚âà x/ln(x)</p>
                <p><strong>Historic Insight:</strong> In 1792, 15-year-old Gauss predicted œÄ(x) ‚âà Li(x). Our RH verification directly validates this prediction!</p>
                
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 12px;">
                    <tr style="background: rgba(255,255,255,0.1);">
                        <th style="padding: 8px; border: 1px solid #666;">x</th>
                        <th style="padding: 8px; border: 1px solid #666;">œÄ(x) actual</th>
                        <th style="padding: 8px; border: 1px solid #666;">Li(x) Gauss</th>
                        <th style="padding: 8px; border: 1px solid #666;">Error</th>
                        <th style="padding: 8px; border: 1px solid #666;">Error %</th>
                    </tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10¬≥</td><td style="padding: 6px; border: 1px solid #666;">168</td><td style="padding: 6px; border: 1px solid #666;">178</td><td style="padding: 6px; border: 1px solid #666;">+10</td><td style="padding: 6px; border: 1px solid #666;">5.9%</td></tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10‚Å∂</td><td style="padding: 6px; border: 1px solid #666;">78,498</td><td style="padding: 6px; border: 1px solid #666;">78,628</td><td style="padding: 6px; border: 1px solid #666;">+130</td><td style="padding: 6px; border: 1px solid #666;">0.17%</td></tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10‚Åπ</td><td style="padding: 6px; border: 1px solid #666;">50,847,534</td><td style="padding: 6px; border: 1px solid #666;">50,849,235</td><td style="padding: 6px; border: 1px solid #666;">+1,701</td><td style="padding: 6px; border: 1px solid #666;">0.003%</td></tr>
                </table>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">How Our Verification Validates Prime Behavior</h5>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 10px;">
                    <h6 style="color: #ff6b6b; margin: 0 0 8px 0;">üåü When Ratio < 1.0</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Prime gaps stay close to ln(x)</li>
                        <li>No large "prime deserts"</li>
                        <li>Gauss's formula is highly accurate</li>
                        <li>Cryptographic security is strong</li>
                    </ul>
                </div>
                
                <div style="background: rgba(254, 202, 87, 0.1); border-left: 4px solid #feca57; padding: 10px;">
                    <h6 style="color: #feca57; margin: 0 0 8px 0;">‚≠ê Major Arc Dominance</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Primes in arithmetic progressions behave regularly</li>
                        <li>Dirichlet's theorem is validated</li>
                        <li>Twin prime patterns follow predictions</li>
                        <li>Hardy-Littlewood conjectures gain support</li>
                    </ul>
                </div>
                
                <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 10px;">
                    <h6 style="color: #4ecdc4; margin: 0 0 8px 0;">üìä Low Variance Results</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Primes avoid excessive clustering</li>
                        <li>Cram√©r's conjecture gains support</li>
                        <li>Random matrix connections validated</li>
                        <li>Prime Number Theorem error bounds tight</li>
                    </ul>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">Real-World Applications</h5>
            <div style="background: rgba(150, 206, 180, 0.1); border-radius: 8px; padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;">üîê Cryptography</h6>
                        <p style="margin: 0; font-size: 12px;">RSA security, prime generation, key sizing, factoring difficulty bounds</p>
                    </div>
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;">üßÆ Algorithms</h6>
                        <p style="margin: 0; font-size: 12px;">Primality testing, hash functions, pseudorandom generators, sieve optimization</p>
                    </div>
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;">üìö Mathematics</h6>
                        <p style="margin: 0; font-size: 12px;">L-functions, automorphic forms, analytic number theory, additive combinatorics</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">What Our M√∂bius Sums Reveal</h5>
            <p>The exponential sums S(N,Œ±) = Œ£ Œº(n)e^(2œÄinŒ±) are intimately connected to prime distribution through:</p>
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 15px; font-family: 'Courier New', monospace; margin: 10px 0;">
                <div style="text-align: center; margin-bottom: 10px;">œÄ(x) = Li(x) - Œ£<sub>œÅ</sub> Li(x<sup>œÅ</sup>) + O(x<sup>Œ∏</sup>)</div>
                <div style="font-size: 11px; text-align: center; color: #a0a0a0;">Riemann's exact prime counting formula</div>
            </div>
            <ul style="font-size: 13px; margin: 10px 0;">
                <li><strong>Small ratios |S(N,Œ±)|/‚àöN:</strong> Error terms œÄ(x) - Li(x) are controlled ‚â™ ‚àöx ln(x)</li>
                <li><strong>Major arc peaks:</strong> Primes in arithmetic progressions follow Dirichlet predictions</li>
                <li><strong>Smooth convergence:</strong> No chaotic behavior - primes are "well-distributed"</li>
                <li><strong>Low variance:</strong> Prime gaps stay near logarithmic average</li>
            </ul>
            
            <div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1)); border-radius: 8px; padding: 15px; margin: 15px 0; border: 1px solid rgba(78, 205, 196, 0.3);">
                <h6 style="color: #4ecdc4; margin: 0 0 10px 0;">üéØ The Beautiful Connection</h6>
                <p style="margin: 0; font-style: italic;">Every successful RH verification means: <strong>"Primes are distributed so regularly that a teenager's 1792 intuition predicts their count to within ‚àöN accuracy!"</strong></p>
                <p style="margin: 10px 0 0 0; font-size: 12px;">When you see smooth, low-ratio visualizations, you're witnessing computational proof that the universe's prime distribution follows deep, predictable patterns that Gauss intuited over 230 years ago.</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>üéØ Test Configuration</h3>
                
                <label for="maxN">Maximum N:</label>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="setPreset(100000)">100K</button>
                    <button class="preset-btn" onclick="setPreset(500000)">500K</button>
                    <button class="preset-btn" onclick="setPreset(1000000)">1M</button>
                    <button class="preset-btn" onclick="setPreset(5000000)">5M</button>
                    <button class="preset-btn" onclick="setPreset(10000000)">10M</button>
                    <button class="preset-btn" onclick="setPreset(25000000)">25M</button>
                    <button class="preset-btn" onclick="setPreset(50000000)">50M</button>
                    <button class="preset-btn" onclick="setPreset(100000000)">100M</button>
                </div>
                <input type="number" id="customN" value="1000000" min="1" max="100000000" placeholder="Enter custom N value">
                
                <div id="performanceIndicator" class="performance-indicator perf-excellent">
                    ‚ö° Excellent performance expected (~1-2 seconds)
                </div>
                
                <label for="testMode">Test Mode:</label>
                <select id="testMode">
                    <option value="stochastic">Stochastic Œ± sampling</option>
                    <option value="major-arcs" selected>Major arcs analysis</option>
                    <option value="uniform">Uniform grid</option>
                    <option value="comprehensive">Comprehensive (all methods)</option>
                    <option value="adaptive">Adaptive precision</option>
                </select>
            </div>
            
            <div class="control-group">
                <h3>‚öôÔ∏è Sampling Parameters</h3>
                
                <div class="two-column">
                    <div>
                        <label for="numSamples">Number of Œ± samples:</label>
                        <input type="number" id="numSamples" value="100" min="10" max="2000">
                        <small>More samples = better coverage</small>
                    </div>
                    
                    <div>
                        <label for="maxDenom">Max denominator (major arcs):</label>
                        <input type="number" id="maxDenom" value="12" min="2" max="50">
                        <small>Higher values test more rational Œ± = a/q</small>
                    </div>
                </div>
                
                <div class="two-column">
                    <div>
                        <label for="gridSize">Grid size (uniform mode):</label>
                        <input type="number" id="gridSize" value="64" min="8" max="256">
                        <small>Grid resolution for uniform sampling</small>
                    </div>
                    
                    <div>
                        <label for="precisionLevel">Precision level:</label>
                        <select id="precisionLevel">
                            <option value="standard">Standard</option>
                            <option value="high" selected>High</option>
                            <option value="ultra">Ultra (slow)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üìä Visualization & Analysis</h3>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showDetails" checked>
                    <label for="showDetails">Show detailed analysis</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="generateHeatmap" checked>
                    <label for="generateHeatmap">Generate complexity heatmap</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showStatistics" checked>
                    <label for="showStatistics">Statistical analysis</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="realTimeUpdates">
                    <label for="realTimeUpdates">Real-time progress updates</label>
                </div>
                
                <div class="advanced-options">
                    <h4 style="margin-top: 0; color: #96ceb4;">Advanced Options</h4>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enablePhaseAnalysis">
                        <label for="enablePhaseAnalysis">Phase analysis</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableDistributionAnalysis">
                        <label for="enableDistributionAnalysis">Distribution analysis</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableFrequencyAnalysis">
                        <label for="enableFrequencyAnalysis">Frequency domain analysis</label>
                    </div>
                </div>
                
                <button id="startTest">üöÄ Launch Enhanced Cosmic Test</button>
            </div>
        </div>
        
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="statusText" class="status computing">Initializing enhanced computation...</div>
        </div>
        
        <div class="results" id="results" style="display: none;">
            <h3>üìä Enhanced Cosmic Verification Results</h3>
            
            <div class="metrics-grid">
                <div class="metric">
                    <span class="metric-label">Maximum N tested:</span>
                    <span class="metric-value" id="resultN">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">‚àöN (theoretical bound):</span>
                    <span class="metric-value" id="resultSqrtN">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Maximum |S(N,Œ±)| found:</span>
                    <span class="metric-value" id="resultMaxSum">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Ratio |S(N,Œ±)|/‚àöN:</span>
                    <span class="metric-value" id="resultRatio">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Best Œ± value:</span>
                    <span class="metric-value" id="resultBestAlpha">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Computation time:</span>
                    <span class="metric-value" id="computeTime">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Operations per second:</span>
                    <span class="metric-value" id="opsPerSec">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Memory efficiency:</span>
                    <span class="metric-value" id="memoryEff">-</span>
                </div>
            </div>

            <div class="cosmic-status" id="cosmicStatus" style="display: none;">
                üåü Status will appear here
            </div>
            
            <div id="statisticalSummary" style="display: none;">
                <h4 style="color: #4ecdc4; margin-bottom: 15px;">Statistical Summary</h4>
                <div class="statistics-grid" id="statsGrid">
                    <!-- Statistics will be populated here -->
                </div>
            </div>
            
            <div id="detailedResults" style="display: none;" class="detailed-results">
                <div class="results-tabs">
                    <button class="tab-button active" onclick="switchTab('topResults')">Top Results</button>
                    <button class="tab-button" onclick="switchTab('insights')">Mathematical Insights</button>
                    <button class="tab-button" onclick="switchTab('distribution')">Distribution Analysis</button>
                    <button class="tab-button" onclick="switchTab('phase')">Phase Analysis</button>
                    <button class="tab-button" onclick="switchTab('export')">Export Data</button>
                </div>
                
                <div id="topResults" class="tab-content active">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Top Exponential Sum Values</h4>
                    <table class="top-results-table" id="topResultsTable">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Œ± value</th>
                                <th>|S(N,Œ±)|</th>
                                <th>Ratio</th>
                                <th>Type</th>
                            </tr>
                        </thead>
                        <tbody id="topResultsBody">
                        </tbody>
                    </table>
                </div>
                
                <div id="insights" class="tab-content">
                    <div class="insights">
                        <h5 style="color: #4ecdc4; margin-bottom: 10px;">Mathematical Insights</h5>
                        <div id="insightsContent">
                            <p>Complete a test to see detailed analysis and insights.</p>
                        </div>
                    </div>
                </div>
                
                <div id="distribution" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Distribution Analysis</h4>
                    <div id="distributionAnalysis">
                        <p>Distribution analysis will appear here after computation.</p>
                    </div>
                </div>
                
                <div id="phase" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Phase Analysis</h4>
                    <div id="phaseAnalysis">
                        <p>Phase analysis will appear here after computation.</p>
                    </div>
                </div>
                
                <div id="export" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Export Data</h4>
                    <div class="export-buttons">
                        <button class="export-btn" onclick="exportResults('csv')">üìÑ Export CSV</button>
                        <button class="export-btn" onclick="exportResults('json')">üìã Export JSON</button>
                        <button class="export-btn" onclick="exportResults('txt')">üìù Export Report</button>
                        <button class="export-btn" onclick="exportVisualization()">üñºÔ∏è Export Charts</button>
                    </div>
                    <p style="margin-top: 15px; color: #a0a0a0;">Export your results in various formats for further analysis or sharing.</p>
                </div>
            </div>
        </div>
        
        <div class="visualization-grid" id="visualizationGrid" style="display: none;">
            <div class="visualization-item">
                <h4>Exponential Sum Distribution</h4>
                <canvas id="sumChart" width="400" height="300"></canvas>
                <div class="chart-info" id="sumChartInfo">
                    <div class="chart-info-title">Click on points to see details</div>
                    <div id="sumChartDetails">Hover over data points or click for exact values</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Complexity Heatmap</h4>
                <div class="heatmap-container">
                    <canvas id="heatmapChart" width="400" height="300"></canvas>
                    <div class="chart-info" id="heatmapInfo">
                        <div class="chart-info-title">Heatmap Values</div>
                        <div id="heatmapDetails">Click on cells to see sum values</div>
                    </div>
                    <div class="heatmap-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ecdc4;"></div>
                            <span>Low</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #feca57;"></div>
                            <span>Medium</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b6b;"></div>
                            <span>High</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Phase Distribution</h4>
                <canvas id="phaseChart" width="400" height="300"></canvas>
                <div class="chart-info" id="phaseChartInfo">
                    <div class="chart-info-title">Phase Analysis</div>
                    <div id="phaseChartDetails">Click on points to see phase and magnitude</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Convergence Analysis</h4>
                <canvas id="convergenceChart" width="400" height="300"></canvas>
                <div class="chart-info" id="convergenceChartInfo">
                    <div class="chart-info-title">Convergence Data</div>
                    <div id="convergenceChartDetails">Click on the line to see iteration details</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Ratio vs Œ± Scatter Plot</h4>
                <canvas id="scatterChart" width="400" height="300"></canvas>
                <div class="chart-info" id="scatterChartInfo">
                    <div class="chart-info-title">Scatter Plot Data</div>
                    <div id="scatterChartDetails">Click on points to see Œ± and ratio values</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Statistical Distribution</h4>
                <canvas id="histogramChart" width="400" height="300"></canvas>
                <div class="chart-info" id="histogramInfo">
                    <div class="chart-info-title">Histogram Data</div>
                    <div id="histogramDetails">Click on bars to see frequency counts</div>
                </div>
            </div>
        </div>
        
        <!-- Tooltip for interactive charts -->
        <div class="chart-tooltip" id="chartTooltip"></div>
    </div>

    <script>
        class EnhancedRiemannHypothesisTester {
            constructor() {
                this.mobius = [];
                this.maxN = 0;
                this.isComputing = false;
                this.results = [];
                this.phaseData = [];
                this.convergenceData = [];
                this.currentTest = null;
            }

            // Optimized M√∂bius function computation using sieve method
            computeMobius(n) {
                console.log('Computing M√∂bius function up to ' + n + '...');
                const startTime = performance.now();
                
                this.mobius = new Int8Array(n + 1);
                const smallestPrimeFactor = new Array(n + 1).fill(0);
                
                // Initialize
                this.mobius[1] = 1;
                
                // Sieve to find smallest prime factors
                for (let i = 2; i <= n; i++) {
                    if (smallestPrimeFactor[i] === 0) {
                        // i is prime
                        smallestPrimeFactor[i] = i;
                        for (let j = i * i; j <= n; j += i) {
                            if (smallestPrimeFactor[j] === 0) {
                                smallestPrimeFactor[j] = i;
                            }
                        }
                    }
                }
                
                // Compute M√∂bius function using multiplicative property
                for (let i = 2; i <= n; i++) {
                    const p = smallestPrimeFactor[i];
                    const quotient = Math.floor(i / p);
                    
                    if (quotient % p === 0) {
                        // i is divisible by p¬≤, so Œº(i) = 0
                        this.mobius[i] = 0;
                    } else {
                        // Œº(i) = -Œº(i/p) since p is the smallest prime factor
                        this.mobius[i] = -this.mobius[quotient];
                    }
                }
                
                const endTime = performance.now();
                console.log('M√∂bius computation completed in ' + (endTime - startTime).toFixed(2) + 'ms');
                this.maxN = n;
            }

            // Enhanced exponential sum computation with phase tracking
            computeExponentialSum(N, alpha, trackPhase = false) {
                let realSum = 0;
                let imagSum = 0;
                let phases = [];
                
                for (let n = 1; n <= N; n++) {
                    if (this.mobius[n] !== 0) {
                        const angle = 2 * Math.PI * n * alpha;
                        const cosVal = Math.cos(angle);
                        const sinVal = Math.sin(angle);
                        
                        realSum += this.mobius[n] * cosVal;
                        imagSum += this.mobius[n] * sinVal;
                        
                        if (trackPhase && n % Math.max(1, Math.floor(N / 50)) === 0) {
                            phases.push({
                                n: n,
                                phase: Math.atan2(imagSum, realSum),
                                magnitude: Math.sqrt(realSum * realSum + imagSum * imagSum),
                                alpha: alpha
                            });
                        }
                    }
                }
                
                const magnitude = Math.sqrt(realSum * realSum + imagSum * imagSum);
                const phase = Math.atan2(imagSum, realSum);
                
                return {
                    magnitude: magnitude,
                    phase: phase,
                    real: realSum,
                    imaginary: imagSum,
                    phases: phases
                };
            }

            // Generate enhanced Œ± values based on mode and precision
            generateAlphaValues(mode, numSamples, maxDenom, gridSize, precision) {
                const alphas = [];
                
                switch (mode) {
                    case 'stochastic':
                        for (let i = 0; i < numSamples; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'major-arcs':
                        // Test rational numbers with small denominators
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                }
                            }
                        }
                        // Add some random values too
                        const randomCount = Math.min(Math.floor(numSamples / 2), 100);
                        for (let i = 0; i < randomCount; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'uniform':
                        for (let i = 0; i < gridSize; i++) {
                            for (let j = 0; j < gridSize; j++) {
                                alphas.push((i + 0.5) / gridSize);
                                if (alphas.length >= numSamples) break;
                            }
                            if (alphas.length >= numSamples) break;
                        }
                        break;
                        
                    case 'adaptive':
                        // Start with major arcs, then adaptively refine
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                    // Add nearby points for adaptive refinement
                                    if (precision === 'high' || precision === 'ultra') {
                                        const delta = precision === 'ultra' ? 0.001 : 0.01;
                                        alphas.push((p / q) + delta);
                                        alphas.push((p / q) - delta);
                                    }
                                }
                            }
                        }
                        // Add adaptive grid points
                        for (let i = 0; i < numSamples; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'comprehensive':
                        // Combine all methods for thorough testing
                        // Major arcs
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                }
                            }
                        }
                        // Uniform grid
                        for (let i = 0; i < gridSize; i++) {
                            alphas.push(i / gridSize);
                        }
                        // Random sampling
                        for (let i = 0; i < Math.floor(numSamples / 2); i++) {
                            alphas.push(Math.random());
                        }
                        break;
                }
                
                return [...new Set(alphas.map(a => Math.abs(a % 1)))]; // Remove duplicates and normalize
            }

            gcd(a, b) {
                while (b !== 0) {
                    [a, b] = [b, a % b];
                }
                return a;
            }

            formatAlpha(alpha) {
                // Try to express as a simple fraction
                const tolerance = 1e-10;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            return num + '/' + denom;
                        }
                    }
                }
                return alpha.toFixed(8);
            }

            determineAlphaType(alpha) {
                const tolerance = 1e-10;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            if (denom <= 12) return 'Major Arc';
                            return 'Rational';
                        }
                    }
                }
                return 'Irrational';
            }

            async runEnhancedVerification(maxN, testMode, numSamples, maxDenom, gridSize, precision, options) {
                return new Promise((resolve) => {
                    const startTime = performance.now();
                    
                    // Update UI
                    document.getElementById('progressContainer').style.display = 'block';
                    document.getElementById('results').style.display = 'none';
                    document.getElementById('visualizationGrid').style.display = 'none';
                    
                    const updateProgress = (message, progress) => {
                        document.getElementById('statusText').textContent = message;
                        document.getElementById('progressFill').style.width = progress + '%';
                    };
                    
                    // Initialize variables at the top level
                    let maxSum = 0;
                    let bestAlpha = 0;
                    const results = [];
                    const convergencePoints = [];
                    let phaseData = []; // Declare at function scope
                    
                    // Store phaseData in instance for later access
                    this.phaseData = [];
                    
                    setTimeout(() => {
                        updateProgress('Computing enhanced M√∂bius function...', 5);
                        
                        setTimeout(() => {
                            // Step 1: Compute M√∂bius function
                            this.computeMobius(maxN);
                            updateProgress('Generating Œ± test values with ' + precision + ' precision...', 15);
                            
                            setTimeout(() => {
                                // Step 2: Generate Œ± values
                                const alphas = this.generateAlphaValues(testMode, numSamples, maxDenom, gridSize, precision);
                                updateProgress('Testing ' + alphas.length + ' Œ± values with enhanced analysis...', 25);
                                
                                setTimeout(() => {
                                    // Step 3: Test exponential sums with enhanced tracking
                                    const sqrtN = Math.sqrt(maxN);
                                    
                                    alphas.forEach((alpha, i) => {
                                        const trackPhase = options.enablePhaseAnalysis && i < 10;
                                        const sumResult = this.computeExponentialSum(maxN, alpha, trackPhase);
                                        
                                        results.push({
                                            alpha: alpha,
                                            sum: sumResult.magnitude,
                                            phase: sumResult.phase,
                                            real: sumResult.real,
                                            imaginary: sumResult.imaginary,
                                            type: this.determineAlphaType(alpha)
                                        });
                                        
                                        if (trackPhase && sumResult.phases && sumResult.phases.length > 0) {
                                            phaseData = phaseData.concat(sumResult.phases);
                                            this.phaseData = this.phaseData.concat(sumResult.phases);
                                        }
                                        
                                        if (sumResult.magnitude > maxSum) {
                                            maxSum = sumResult.magnitude;
                                            bestAlpha = alpha;
                                        }
                                        
                                        // Track convergence
                                        if (i % Math.max(1, Math.floor(alphas.length / 20)) === 0) {
                                            convergencePoints.push({
                                                iteration: i,
                                                maxSum: maxSum,
                                                currentSum: sumResult.magnitude
                                            });
                                        }
                                        
                                        if (options.realTimeUpdates && i % Math.max(1, Math.floor(alphas.length / 20)) === 0) {
                                            const progress = 25 + 65 * (i / alphas.length);
                                            updateProgress('Testing Œ± values... ' + (i + 1) + '/' + alphas.length + ' (max: ' + maxSum.toFixed(3) + ')', progress);
                                        }
                                    });
                                    
                                    const endTime = performance.now();
                                    const computeTime = endTime - startTime;
                                    const ratio = maxSum / sqrtN;
                                    
                                    updateProgress('Generating advanced visualizations...', 95);
                                    
                                    setTimeout(() => {
                                        updateProgress('Enhanced computation complete!', 100);
                                        
                                        resolve({
                                            maxN,
                                            sqrtN,
                                            maxSum,
                                            ratio,
                                            bestAlpha,
                                            computeTime,
                                            results: results.sort((a, b) => b.sum - a.sum),
                                            phaseData: phaseData,
                                            convergenceData: convergencePoints,
                                            statistics: this.calculateStatistics(results),
                                            options
                                        });
                                    }, 200);
                                }, 100);
                            }, 100);
                        }, 100);
                    }, 100);
                });
            }

            calculateStatistics(results) {
                const sums = results.map(r => r.sum);
                const phases = results.map(r => r.phase);
                
                return {
                    mean: sums.reduce((a, b) => a + b, 0) / sums.length,
                    median: this.median(sums),
                    stdDev: this.standardDeviation(sums),
                    variance: this.variance(sums),
                    skewness: this.skewness(sums),
                    kurtosis: this.kurtosis(sums),
                    min: Math.min(...sums),
                    max: Math.max(...sums),
                    q1: this.percentile(sums, 25),
                    q3: this.percentile(sums, 75),
                    majorArcCount: results.filter(r => r.type === 'Major Arc').length,
                    rationalCount: results.filter(r => r.type === 'Rational').length,
                    irrationalCount: results.filter(r => r.type === 'Irrational').length
                };
            }

            median(arr) {
                const sorted = [...arr].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
            }

            standardDeviation(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
                return Math.sqrt(variance);
            }

            variance(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                return arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
            }

            skewness(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = this.standardDeviation(arr);
                const n = arr.length;
                return arr.reduce((sum, val) => sum + Math.pow((val - mean) / std, 3), 0) / n;
            }

            kurtosis(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = this.standardDeviation(arr);
                const n = arr.length;
                return arr.reduce((sum, val) => sum + Math.pow((val - mean) / std, 4), 0) / n - 3;
            }

            percentile(arr, p) {
                const sorted = [...arr].sort((a, b) => a - b);
                const index = (p / 100) * (sorted.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                return sorted[lower] + (sorted[upper] - sorted[lower]) * (index - lower);
            }

            displayEnhancedResults(results) {
                const {maxN, sqrtN, maxSum, ratio, bestAlpha, computeTime, results: topResults, statistics, options} = results;
                
                // Basic metrics
                document.getElementById('resultN').textContent = maxN.toLocaleString();
                document.getElementById('resultSqrtN').textContent = sqrtN.toFixed(2);
                document.getElementById('resultMaxSum').textContent = maxSum.toFixed(6);
                document.getElementById('resultRatio').textContent = ratio.toFixed(8);
                document.getElementById('resultBestAlpha').textContent = this.formatAlpha(bestAlpha);
                document.getElementById('computeTime').textContent = (computeTime/1000).toFixed(3) + 's';
                document.getElementById('opsPerSec').textContent = (maxN / (computeTime/1000)).toExponential(3);
                document.getElementById('memoryEff').textContent = (maxN / (1024 * 1024)).toFixed(2) + 'MB';
                
                // Enhanced RH status with cosmic themes
                let rhStatus, rhClass;
                if (ratio < 0.2) {
                    rhStatus = 'üåå COSMIC EXCELLENCE - Extraordinary RH Support (ratio < 0.2)';
                    rhClass = 'status-cosmic';
                } else if (ratio < 0.4) {
                    rhStatus = 'üåü LEGENDARY - Outstanding RH Support (ratio < 0.4)';
                    rhClass = 'status-legendary';
                } else if (ratio < 0.8) {
                    rhStatus = '‚ú® MYTHICAL - Excellent RH Support (ratio < 0.8)';
                    rhClass = 'status-mythical';
                } else if (ratio < 1.5) {
                    rhStatus = '‚≠ê EXCELLENT - Good RH Support (ratio < 1.5)';
                    rhClass = 'status-excellent';
                } else if (ratio < 3.0) {
                    rhStatus = 'üëç GOOD - Acceptable RH Support (ratio < 3.0)';
                    rhClass = 'status-good';
                } else {
                    rhStatus = '‚ö†Ô∏è HIGH - Needs Investigation (ratio ‚â• 3.0)';
                    rhClass = 'status-high';
                }
                
                const statusElement = document.getElementById('cosmicStatus');
                statusElement.textContent = rhStatus;
                statusElement.className = 'cosmic-status ' + rhClass;
                statusElement.style.display = 'block';
                
                // Statistical summary
                if (options.showStatistics && statistics) {
                    this.displayStatistics(statistics);
                    document.getElementById('statisticalSummary').style.display = 'block';
                }
                
                // Show detailed results if enabled
                if (options.showDetails) {
                    this.displayDetailedResults(topResults, maxN, sqrtN, ratio, statistics);
                    document.getElementById('detailedResults').style.display = 'block';
                } else {
                    document.getElementById('detailedResults').style.display = 'none';
                }
                
                document.getElementById('results').style.display = 'block';
                document.getElementById('progressContainer').style.display = 'none';
                
                // Store results for export
                this.currentTest = results;
                
                // Generate visualizations
                if (options.generateHeatmap || options.showDetails) {
                    this.generateEnhancedVisualizations(results);
                }
                
                // Debug: Log phase data availability
                console.log('Phase data available:', results.phaseData ? results.phaseData.length : 0, 'points');
                if (results.phaseData && results.phaseData.length > 0) {
                    console.log('First phase point:', results.phaseData[0]);
                }
            }

            displayStatistics(stats) {
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-value">${stats.mean.toFixed(4)}</div>
                        <div class="stat-label">Mean |S(N,Œ±)|</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.median.toFixed(4)}</div>
                        <div class="stat-label">Median |S(N,Œ±)|</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.stdDev.toFixed(4)}</div>
                        <div class="stat-label">Standard Deviation</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.skewness.toFixed(3)}</div>
                        <div class="stat-label">Skewness</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.majorArcCount}</div>
                        <div class="stat-label">Major Arc Results</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${(stats.majorArcCount / (stats.majorArcCount + stats.rationalCount + stats.irrationalCount) * 100).toFixed(1)}%</div>
                        <div class="stat-label">Major Arc Percentage</div>
                    </div>
                `;
            }

            displayDetailedResults(topResults, maxN, sqrtN, ratio, statistics) {
                // Top results table
                const tbody = document.getElementById('topResultsBody');
                tbody.innerHTML = '';
                
                topResults.slice(0, 15).forEach((result, i) => {
                    const resultRatio = result.sum / sqrtN;
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${i + 1}</td>
                        <td>${this.formatAlpha(result.alpha)}</td>
                        <td>${result.sum.toFixed(6)}</td>
                        <td>${resultRatio.toFixed(6)}</td>
                        <td>${result.type}</td>
                    `;
                    tbody.appendChild(row);
                });
                
                // Mathematical insights
                const insights = this.generateEnhancedInsights(topResults, maxN, sqrtN, ratio, statistics);
                document.getElementById('insightsContent').innerHTML = insights;
                
                // Distribution analysis
                if (statistics) {
                    document.getElementById('distributionAnalysis').innerHTML = this.generateDistributionAnalysis(statistics, topResults);
                }
                
                // Phase analysis
                if (results.phaseData && results.phaseData.length > 0) {
                    document.getElementById('phaseAnalysis').innerHTML = this.generatePhaseAnalysis(results.phaseData);
                }
            }

            generateEnhancedInsights(topResults, maxN, sqrtN, ratio, statistics) {
                let insights = '';
                
                // Major arc dominance analysis
                const majorArcResults = topResults.filter(r => r.type === 'Major Arc').slice(0, 10);
                if (majorArcResults.length > 0) {
                    insights += `<p><strong>Major Arc Dominance:</strong> ${majorArcResults.length} of the top 10 exponential sums occur at major arc Œ± values, confirming classical analytic number theory predictions.</p>`;
                }
                
                // Statistical significance
                if (statistics) {
                    insights += `<p><strong>Statistical Profile:</strong> Mean ratio: ${(statistics.mean / sqrtN).toFixed(4)}, Standard deviation: ${(statistics.stdDev / sqrtN).toFixed(4)}, Skewness: ${statistics.skewness.toFixed(3)}. `;
                    
                    if (Math.abs(statistics.skewness) < 0.5) {
                        insights += 'Distribution is approximately symmetric.</p>';
                    } else if (statistics.skewness > 0.5) {
                        insights += 'Distribution shows positive skew (tail towards larger values).</p>';
                    } else {
                        insights += 'Distribution shows negative skew (tail towards smaller values).</p>';
                    }
                }
                
                // RH interpretation with enhanced analysis
                if (ratio < 0.5) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} provides exceptionally strong computational evidence supporting the Riemann Hypothesis for N = ${maxN.toLocaleString()}. This level of bound satisfaction is remarkable.</p>`;
                } else if (ratio < 1.0) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} is well within theoretical bounds, providing solid evidence supporting RH predictions.</p>`;
                } else if (ratio < 2.0) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} remains within reasonable bounds for RH, though elevated. This is still consistent with the O(‚àöN) prediction.</p>`;
                } else {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} is significantly elevated. While potentially still consistent with RH (which allows some flexibility), this warrants deeper investigation.</p>`;
                }
                
                // Computational achievement
                insights += `<p><strong>Computational Achievement:</strong> Successfully verified RH predictions for ${maxN.toLocaleString()} integers using advanced browser-based algorithms, demonstrating modern JavaScript's capability for serious mathematical research.</p>`;
                
                // Research directions
                insights += `<p><strong>Future Research:</strong> Consider investigating the specific Œ± values producing maximal sums, exploring larger N values, or applying these techniques to related L-functions and Dirichlet series.</p>`;
                
                return insights;
            }

            generateDistributionAnalysis(statistics, results) {
                let analysis = `
                    <div class="statistics-grid">
                        <div class="stat-card">
                            <div class="stat-value">${statistics.q1.toFixed(4)}</div>
                            <div class="stat-label">First Quartile (Q1)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${statistics.q3.toFixed(4)}</div>
                            <div class="stat-label">Third Quartile (Q3)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${(statistics.q3 - statistics.q1).toFixed(4)}</div>
                            <div class="stat-label">Interquartile Range</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${statistics.kurtosis.toFixed(3)}</div>
                            <div class="stat-label">Kurtosis</div>
                        </div>
                    </div>
                `;
                
                // Distribution shape analysis
                analysis += '<h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">Distribution Shape Analysis</h5>';
                if (statistics.kurtosis > 0) {
                    analysis += '<p>The distribution exhibits positive kurtosis (heavy tails), indicating more extreme values than a normal distribution would predict.</p>';
                } else {
                    analysis += '<p>The distribution exhibits negative kurtosis (light tails), indicating fewer extreme values than expected.</p>';
                }
                
                // Type distribution
                analysis += '<h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">Œ± Value Type Distribution</h5>';
                analysis += `<p>Major Arcs: ${statistics.majorArcCount}, Rational: ${statistics.rationalCount}, Irrational: ${statistics.irrationalCount}</p>`;
                
                return analysis;
            }

            generatePhaseAnalysis(phaseData) {
                if (!phaseData || phaseData.length === 0) {
                    return '<p>Phase analysis data not available for this test.</p>';
                }
                
                let analysis = '<h5 style="color: #4ecdc4; margin-bottom: 10px;">Phase Behavior Analysis</h5>';
                
                // Calculate phase statistics
                const phases = phaseData.map(p => p.phase);
                const meanPhase = phases.reduce((a, b) => a + b, 0) / phases.length;
                const phaseRange = Math.max(...phases) - Math.min(...phases);
                
                analysis += `<p><strong>Mean Phase:</strong> ${meanPhase.toFixed(4)} radians (${(meanPhase * 180 / Math.PI).toFixed(2)}¬∞)</p>`;
                analysis += `<p><strong>Phase Range:</strong> ${phaseRange.toFixed(4)} radians (${(phaseRange * 180 / Math.PI).toFixed(2)}¬∞)</p>`;
                
                // Phase distribution
                const phaseDistribution = this.analyzePhaseDistribution(phases);
                analysis += `<p><strong>Phase Distribution:</strong> ${phaseDistribution}</p>`;
                
                return analysis;
            }

            analyzePhaseDistribution(phases) {
                const bins = 8;
                const binSize = (2 * Math.PI) / bins;
                const counts = new Array(bins).fill(0);
                
                phases.forEach(phase => {
                    const normalizedPhase = ((phase % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                    const bin = Math.min(Math.floor(normalizedPhase / binSize), bins - 1);
                    counts[bin]++;
                });
                
                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);
                
                if (maxCount - minCount < phases.length * 0.1) {
                    return 'Approximately uniform distribution across phase space';
                } else {
                    return 'Non-uniform phase distribution with clustering';
                }
            }

            generateEnhancedVisualizations(results) {
                const {results: topResults, convergenceData, phaseData, options} = results;
                
                // Main distribution chart
                this.drawDistributionChart(topResults, results.sqrtN);
                
                // Heatmap if enabled
                if (options.generateHeatmap) {
                    this.drawComplexityHeatmap(topResults);
                }
                
                // Phase chart if data available
                if (phaseData && phaseData.length > 0) {
                    this.drawPhaseChart(phaseData);
                }
                
                // Convergence analysis
                if (convergenceData && convergenceData.length > 0) {
                    this.drawConvergenceChart(convergenceData);
                }
                
                // Scatter plot
                this.drawScatterPlot(topResults, results.sqrtN);
                
                // Histogram
                this.drawHistogram(topResults);
                
                document.getElementById('visualizationGrid').style.display = 'grid';
            }

            drawDistributionChart(results, sqrtN) {
                const canvas = document.getElementById('sumChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxSum = Math.max(...results.map(r => r.sum));
                const displayResults = results.slice(0, 50);
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw ‚àöN reference line
                const sqrtNY = canvas.height - padding - (sqrtN / maxSum) * height;
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(padding, sqrtNY);
                ctx.lineTo(canvas.width - padding, sqrtNY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw data points with color coding
                displayResults.forEach((result, i) => {
                    const x = padding + (i / (displayResults.length - 1)) * width;
                    const y = canvas.height - padding - (result.sum / maxSum) * height;
                    
                    // Color by type
                    if (result.type === 'Major Arc') {
                        ctx.fillStyle = '#ff6b6b';
                    } else if (result.type === 'Rational') {
                        ctx.fillStyle = '#feca57';
                    } else {
                        ctx.fillStyle = '#4ecdc4';
                    }
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('Top Œ± values (ranked)', canvas.width / 2 - 50, canvas.height - 10);
                ctx.fillText('‚àöN = ' + sqrtN.toFixed(1), canvas.width - 80, sqrtNY - 5);
            }

            drawComplexityHeatmap(results) {
                const canvas = document.getElementById('heatmapChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const gridSize = 32;
                const cellWidth = canvas.width / gridSize;
                const cellHeight = canvas.height / gridSize;
                
                // Create complexity grid
                const complexityGrid = new Array(gridSize).fill(null).map(() => new Array(gridSize).fill(0));
                
                results.slice(0, gridSize * gridSize).forEach((result, i) => {
                    const x = i % gridSize;
                    const y = Math.floor(i / gridSize);
                    complexityGrid[y][x] = result.sum;
                });
                
                const maxComplexity = Math.max(...results.map(r => r.sum));
                
                // Draw heatmap
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const intensity = complexityGrid[y][x] / maxComplexity;
                        const hue = (1 - intensity) * 180; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            drawPhaseChart(phaseData) {
                const canvas = document.getElementById('phaseChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 30;
                
                // Draw unit circle
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw axes
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX - radius, centerY);
                ctx.lineTo(centerX + radius, centerY);
                ctx.moveTo(centerX, centerY - radius);
                ctx.lineTo(centerX, centerY + radius);
                ctx.stroke();
                
                // If no phase data, show message and simulate some points
                if (!phaseData || phaseData.length === 0) {
                    ctx.fillStyle = '#a0a0a0';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Enable Phase Analysis to see data', centerX, centerY + 60);
                    
                    // Draw some example phase points in a circle pattern
                    ctx.fillStyle = '#666';
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * 2 * Math.PI;
                        const x = centerX + radius * 0.7 * Math.cos(angle);
                        const y = centerY + radius * 0.7 * Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    return;
                }
                
                // Plot actual phase points with color coding by magnitude
                const maxMagnitude = Math.max(...phaseData.map(p => p.magnitude));
                
                phaseData.forEach(point => {
                    const x = centerX + radius * 0.8 * Math.cos(point.phase);
                    const y = centerY + radius * 0.8 * Math.sin(point.phase);
                    
                    // Color based on magnitude
                    const intensity = point.magnitude / maxMagnitude;
                    const hue = intensity * 60; // Red to yellow
                    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Reset text alignment
                ctx.textAlign = 'left';
            }

            drawConvergenceChart(convergenceData) {
                const canvas = document.getElementById('convergenceChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxSum = Math.max(...convergenceData.map(d => d.maxSum));
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw convergence line
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                convergenceData.forEach((point, i) => {
                    const x = padding + (i / (convergenceData.length - 1)) * width;
                    const y = canvas.height - padding - (point.maxSum / maxSum) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('Iteration', canvas.width / 2 - 20, canvas.height - 10);
            }

            drawScatterPlot(results, sqrtN) {
                const canvas = document.getElementById('scatterChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxRatio = Math.max(...results.map(r => r.sum / sqrtN));
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw y = 1 reference line
                const refY = canvas.height - padding - (1 / maxRatio) * height;
                ctx.strokeStyle = '#ff6b6b';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(padding, refY);
                ctx.lineTo(canvas.width - padding, refY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Plot points
                results.slice(0, 100).forEach(result => {
                    const x = padding + (result.alpha * width);
                    const ratio = result.sum / sqrtN;
                    const y = canvas.height - padding - (ratio / maxRatio) * height;
                    
                    ctx.fillStyle = result.type === 'Major Arc' ? '#ff6b6b' : '#4ecdc4';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('Œ± value', canvas.width / 2 - 20, canvas.height - 10);
                ctx.fillText('Ratio = 1', canvas.width - 80, refY - 5);
            }

            drawHistogram(results) {
                const canvas = document.getElementById('histogramChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                // Create histogram bins
                const bins = 20;
                const sums = results.map(r => r.sum);
                const minSum = Math.min(...sums);
                const maxSum = Math.max(...sums);
                const binWidth = (maxSum - minSum) / bins;
                const binCounts = new Array(bins).fill(0);
                
                sums.forEach(sum => {
                    const binIndex = Math.min(Math.floor((sum - minSum) / binWidth), bins - 1);
                    binCounts[binIndex]++;
                });
                
                const maxCount = Math.max(...binCounts);
                const barWidth = width / bins;
                
                // Draw bars
                binCounts.forEach((count, i) => {
                    const barHeight = (count / maxCount) * height;
                    const x = padding + i * barWidth;
                    const y = canvas.height - padding - barHeight;
                    
                    ctx.fillStyle = '#4ecdc4';
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                });
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('|S(N,Œ±)| value', canvas.width / 2 - 30, canvas.height - 10);
            }

            isSimpleRational(alpha) {
                const tolerance = 1e-8;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        // Initialize the enhanced application
        const enhancedTester = new EnhancedRiemannHypothesisTester();

        // Global functions for UI interactions
        function setPreset(value) {
            document.getElementById('customN').value = value;
            updatePerformanceIndicator(value);
            
            // Auto-optimize parameters for large N to prevent memory issues
            if (value >= 50000000) {
                document.getElementById('numSamples').value = '50';
                document.getElementById('maxDenom').value = '8';
                document.getElementById('gridSize').value = '32';
            } else if (value >= 10000000) {
                document.getElementById('numSamples').value = '75';
                document.getElementById('maxDenom').value = '10';
                document.getElementById('gridSize').value = '48';
            } else if (value >= 1000000) {
                document.getElementById('numSamples').value = '100';
                document.getElementById('maxDenom').value = '12';
                document.getElementById('gridSize').value = '64';
            } else {
                document.getElementById('numSamples').value = '150';
                document.getElementById('maxDenom').value = '15';
                document.getElementById('gridSize').value = '64';
            }
        }

        function updatePerformanceIndicator(n) {
            const indicator = document.getElementById('performanceIndicator');
            
            if (n < 100000) {
                indicator.className = 'performance-indicator perf-excellent';
                indicator.innerHTML = '‚ö° Excellent performance expected (< 1 second)';
            } else if (n < 1000000) {
                indicator.className = 'performance-indicator perf-good';
                indicator.innerHTML = 'üü¢ Good performance expected (1-3 seconds)';
            } else if (n < 10000000) {
                indicator.className = 'performance-indicator perf-warning';
                indicator.innerHTML = 'üü° Moderate performance expected (5-15 seconds)';
            } else {
                indicator.className = 'performance-indicator perf-danger';
                indicator.innerHTML = 'üî¥ Slower performance expected (15+ seconds)';
            }
        }

        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab and activate button
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function exportResults(format) {
            if (!enhancedTester.currentTest) {
                alert('No test results to export. Please run a test first.');
                return;
            }
            
            const results = enhancedTester.currentTest;
            let content = '';
            let filename = '';
            let mimeType = '';
            
            switch (format) {
                case 'csv':
                    content = 'Alpha,Sum,Ratio,Type,Phase,Real,Imaginary\n';
                    results.results.forEach(r => {
                        content += `${r.alpha},${r.sum},${r.sum/results.sqrtN},${r.type},${r.phase},${r.real},${r.imaginary}\n`;
                    });
                    filename = `riemann_test_${results.maxN}.csv`;
                    mimeType = 'text/csv';
                    break;
                    
                case 'json':
                    content = JSON.stringify(results, null, 2);
                    filename = `riemann_test_${results.maxN}.json`;
                    mimeType = 'application/json';
                    break;
                    
                case 'txt':
                    content = `Enhanced Riemann Hypothesis Test Report\n`;
                    content += `==========================================\n\n`;
                    content += `Test Parameters:\n`;
                    content += `- Maximum N: ${results.maxN.toLocaleString()}\n`;
                    content += `- ‚àöN bound: ${results.sqrtN.toFixed(6)}\n`;
                    content += `- Maximum |S(N,Œ±)|: ${results.maxSum.toFixed(6)}\n`;
                    content += `- Ratio: ${results.ratio.toFixed(8)}\n`;
                    content += `- Best Œ±: ${enhancedTester.formatAlpha(results.bestAlpha)}\n`;
                    content += `- Computation time: ${(results.computeTime/1000).toFixed(3)}s\n\n`;
                    
                    content += `Statistical Summary:\n`;
                    if (results.statistics) {
                        content += `- Mean: ${results.statistics.mean.toFixed(6)}\n`;
                        content += `- Standard deviation: ${results.statistics.stdDev.toFixed(6)}\n`;
                        content += `- Skewness: ${results.statistics.skewness.toFixed(4)}\n`;
                        content += `- Major arc results: ${results.statistics.majorArcCount}\n`;
                    }
                    
                    content += `\nTop 10 Results:\n`;
                    results.results.slice(0, 10).forEach((r, i) => {
                        content += `${i+1}. Œ±=${enhancedTester.formatAlpha(r.alpha)}, |S|=${r.sum.toFixed(6)}, ratio=${(r.sum/results.sqrtN).toFixed(6)}, type=${r.type}\n`;
                    });
                    
                    filename = `riemann_test_report_${results.maxN}.txt`;
                    mimeType = 'text/plain';
                    break;
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportVisualization() {
            const canvas = document.getElementById('sumChart');
            const url = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = url;
            a.download = 'riemann_visualization.png';
            a.click();
        }

        // Event listeners
        document.getElementById('startTest').addEventListener('click', async function() {
            if (enhancedTester.isComputing) return;
            
            enhancedTester.isComputing = true;
            const button = document.getElementById('startTest');
            button.disabled = true;
            button.textContent = 'Computing...';
            document.body.classList.add('computing');
            
            // Get parameters
            const maxN = parseInt(document.getElementById('customN').value);
            const testMode = document.getElementById('testMode').value;
            const numSamples = parseInt(document.getElementById('numSamples').value);
            const maxDenom = parseInt(document.getElementById('maxDenom').value);
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const precision = document.getElementById('precisionLevel').value;
            
            const options = {
                showDetails: document.getElementById('showDetails').checked,
                generateHeatmap: document.getElementById('generateHeatmap').checked,
                showStatistics: document.getElementById('showStatistics').checked,
                realTimeUpdates: document.getElementById('realTimeUpdates').checked,
                enablePhaseAnalysis: document.getElementById('enablePhaseAnalysis').checked,
                enableDistributionAnalysis: document.getElementById('enableDistributionAnalysis').checked,
                enableFrequencyAnalysis: document.getElementById('enableFrequencyAnalysis').checked
            };
            
            // Validate input
            if (isNaN(maxN) || maxN < 1 || maxN > 100000000) {
                alert('Please enter a valid number between 1 and 100,000,000');
                enhancedTester.isComputing = false;
                button.disabled = false;
                button.textContent = 'üöÄ Launch Enhanced Cosmic Test';
                document.body.classList.remove('computing');
                return;
            }
            
            try {
                const results = await enhancedTester.runEnhancedVerification(maxN, testMode, numSamples, maxDenom, gridSize, precision, options);
                enhancedTester.displayEnhancedResults(results);
            } catch (error) {
                console.error('Enhanced computation error:', error);
                alert('An error occurred during computation. Please try again with smaller parameters.');
            }
            
            enhancedTester.isComputing = false;
            button.disabled = false;
            button.textContent = 'üöÄ Launch Enhanced Cosmic Test';
            document.body.classList.remove('computing');
        });

        // Input validation and performance updates
        document.getElementById('customN').addEventListener('input', function() {
            const value = parseInt(this.value);
            
            if (value > 100000000) {
                this.value = 100000000;
            } else if (value < 1) {
                this.value = 1;
            }
            
            updatePerformanceIndicator(parseInt(this.value));
            
            // Auto-optimize for very large values
            if (value > 25000000) {
                setPreset(value);
            }
        });

        // Initialize with default performance indicator
        updatePerformanceIndicator(1000000);
    </script>
</body>
</html>
