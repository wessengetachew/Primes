
 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime Research by Wessen Getachew Summer 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 5px;
        }

        .nav-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 5px;
            margin-bottom: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .nav-tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            font-weight: 600;
            color: #666;
        }

        .nav-tab.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .tab-content {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .input-group label {
            font-weight: 600;
            color: #555;
        }

        .input-group input {
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
            min-width: 120px;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 16px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e0e0e0;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .result-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
            border-left: 4px solid #667eea;
        }

        .result-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .result-card .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            font-family: 'Courier New', monospace;
        }

        .formula-box {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        }

        .data-table th,
        .data-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .data-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        .chart-container {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        }

        .export-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .status {
            font-weight: 600;
            margin: 10px 0;
        }

        .status.computing { color: #ffa500; }
        .status.complete { color: #28a745; }
        .status.error { color: #dc3545; }

        .math-display {
            font-size: 1.1em;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }

        .explanation {
            background: #e3f2fd;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .nav-tabs {
                flex-direction: column;
                gap: 5px;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .results-grid {
                grid-template-columns: 1fr;
            }
            
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Prime Research Explorer</h1>
            <p><strong>by Wessen Getachew</strong></p>
            <p>Summer 2025</p>
            <div class="math-display">
                Identity: (p-1)(p-2)/p² = (1-1/(p-1)²)(1-1/p)³
            </div>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('identity')">Identity Explorer</button>
            <button class="nav-tab" onclick="showTab('computation')">Prime Products</button>
            <button class="nav-tab" onclick="showTab('analysis')">Asymptotic Analysis</button>
            <button class="nav-tab" onclick="showTab('comparison')">Telescoping vs Primes</button>
            <button class="nav-tab" onclick="showTab('theory')">Theory & Applications</button>
        </div>

        <!-- Identity Explorer Tab -->
        <div id="identity" class="tab-content active">
            <h2>Identity Verification</h2>
            <div class="explanation">
                <h3>The Core Identity</h3>
                <p>We explore the algebraic identity that works for any real number p ≠ 0, 1:</p>
                <div class="math-display">
                    <strong>(p-1)(p-2)/p² = (1-1/(p-1)²)(1-1/p)³</strong>
                </div>
            </div>

            <div class="input-group">
                <label for="testValue">Test Value (p):</label>
                <input type="number" id="testValue" value="5" step="0.1">
                <button class="btn btn-primary" onclick="verifyIdentity()">Verify Identity</button>
            </div>

            <div id="identityResults"></div>

            <div class="formula-box">
                <h3>Step-by-Step Verification:</h3>
                <div id="stepByStep"></div>
            </div>
        </div>

        <!-- Prime Products Tab -->
        <div id="computation" class="tab-content">
            <h2>Prime Product Computation</h2>
            <div class="explanation">
                <h3>Finite Prime Products</h3>
                <p>Compute the product ∏(p-1)(p-2)/p² over primes in a range and see its factorization into twin and Mertens components.</p>
            </div>

            <div class="input-group">
                <label for="startPrime">Start Prime:</label>
                <input type="number" id="startPrime" value="3" min="3">
                <label for="endPrime">End Prime:</label>
                <input type="number" id="endPrime" value="100" min="3">
                <button class="btn btn-primary" onclick="computePrimeProduct()">Compute</button>
                <button class="btn btn-secondary" onclick="exportResults('computation')">Export Results</button>
            </div>

            <div class="progress-bar" id="computeProgress" style="display: none;">
                <div class="progress-fill" id="computeProgressFill"></div>
            </div>
            <div class="status" id="computeStatus"></div>

            <div id="primeResults"></div>

            <div class="chart-container" id="primeChart" style="display: none;">
                <canvas id="primeCanvas" width="800" height="400"></canvas>
            </div>
        </div>

        <!-- Asymptotic Analysis Tab -->
        <div id="analysis" class="tab-content">
            <h2>Asymptotic Behavior</h2>
            <div class="explanation">
                <h3>Growth Analysis</h3>
                <p>Study how the prime products behave asymptotically and compare with theoretical predictions.</p>
            </div>

            <div class="input-group">
                <label for="maxRange">Maximum Range:</label>
                <input type="number" id="maxRange" value="1000" min="10">
                <label for="numPoints">Number of Points:</label>
                <input type="number" id="numPoints" value="20" min="5" max="50">
                <button class="btn btn-primary" onclick="analyzeAsymptotics()">Analyze</button>
                <button class="btn btn-secondary" onclick="exportResults('analysis')">Export Analysis</button>
            </div>

            <div class="progress-bar" id="analysisProgress" style="display: none;">
                <div class="progress-fill" id="analysisProgressFill"></div>
            </div>
            <div class="status" id="analysisStatus"></div>

            <div id="asymptoticResults"></div>

            <div class="chart-container" id="asymptoticChart" style="display: none;">
                <canvas id="asymptoticCanvas" width="800" height="400"></canvas>
            </div>
        </div>

        <!-- Comparison Tab -->
        <div id="comparison" class="tab-content">
            <h2>Telescoping: Integers vs Primes</h2>
            <div class="explanation">
                <h3>Key Distinction</h3>
                <p>Understand why the identity telescopes for consecutive integers but not for primes.</p>
            </div>

            <div class="input-group">
                <label for="comparisonN">Upper Limit (n):</label>
                <input type="number" id="comparisonN" value="20" min="3">
                <button class="btn btn-primary" onclick="compareTelescopingVsPrimes()">Compare</button>
                <button class="btn btn-secondary" onclick="exportResults('comparison')">Export Comparison</button>
            </div>

            <div id="comparisonResults"></div>
        </div>

        <!-- Theory Tab -->
        <div id="theory" class="tab-content">
            <h2>Theoretical Background & Applications</h2>
            
            <div class="explanation">
                <h3>Mathematical Context</h3>
                <p>Explore the connections to twin prime research, Hardy-Littlewood constants, and Mertens' theorem.</p>
            </div>

            <div class="results-grid">
                <div class="result-card">
                    <h3>Hardy-Littlewood Twin Constant</h3>
                    <div class="value">C₂ ≈ 0.66016</div>
                    <p>The infinite product ∏(1-1/(p-1)²) over all odd primes.</p>
                </div>
                
                <div class="result-card">
                    <h3>Mertens' Constant</h3>
                    <div class="value">e^(-γ) ≈ 0.56146</div>
                    <p>Related to the asymptotic behavior of ∏(1-1/p).</p>
                </div>
                
                <div class="result-card">
                    <h3>Asymptotic Decay</h3>
                    <div class="value">∼ (log y)^(-3)</div>
                    <p>The prime product decays cubically due to Mertens factors.</p>
                </div>
                
                <div class="result-card">
                    <h3>Applications</h3>
                    <div class="value">Sieve Theory</div>
                    <p>Useful for twin prime research and computational number theory.</p>
                </div>
            </div>

            <div class="formula-box">
                <h3>Key Formulas:</h3>
                <p><strong>Main Identity:</strong> (p-1)(p-2)/p² = (1-1/(p-1)²)(1-1/p)³</p>
                <p><strong>Prime Product:</strong> ∏(p-1)(p-2)/p² = C_twin(y) × [M(y)]³</p>
                <p><strong>Telescoping (integers):</strong> ∏(k-1)(k-2)/k² = 4/(n²(n-1))</p>
                <p><strong>Asymptotic:</strong> R_modular(y) ∼ 2C₂e^(-3γ)/(log y)³</p>
            </div>

            <div class="input-group">
                <button class="btn btn-secondary" onclick="exportResults('theory')">Export Theory Summary</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables for storing results
        let currentResults = {};
        let computationHistory = [];

        // Utility functions
        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function getPrimesUpTo(limit) {
            const primes = [];
            for (let i = 2; i <= limit; i++) {
                if (isPrime(i)) primes.push(i);
            }
            return primes;
        }

        function formatNumber(num, precision = 10) {
            if (Math.abs(num) < 1e-15) return "0";
            if (Math.abs(num) > 1e10 || Math.abs(num) < 1e-6) {
                return num.toExponential(precision);
            }
            return num.toPrecision(precision);
        }

        // Tab management
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Identity verification
        function verifyIdentity() {
            const p = parseFloat(document.getElementById('testValue').value);
            
            if (p === 0 || p === 1) {
                alert('Please choose p ≠ 0, 1');
                return;
            }

            // Left side: (p-1)(p-2)/p²
            const leftSide = (p - 1) * (p - 2) / (p * p);

            // Right side: (1-1/(p-1)²)(1-1/p)³
            const term1 = 1 - 1 / ((p - 1) * (p - 1));
            const term2 = Math.pow(1 - 1/p, 3);
            const rightSide = term1 * term2;

            const difference = Math.abs(leftSide - rightSide);
            const isValid = difference < 1e-12;

            currentResults.identity = {
                p: p,
                leftSide: leftSide,
                rightSide: rightSide,
                difference: difference,
                isValid: isValid
            };

            displayIdentityResults();
            displayStepByStep(p, leftSide, rightSide, term1, term2);
        }

        function displayIdentityResults() {
            const result = currentResults.identity;
            const html = `
                <div class="results-grid">
                    <div class="result-card">
                        <h3>Test Value</h3>
                        <div class="value">p = ${result.p}</div>
                    </div>
                    <div class="result-card">
                        <h3>Left Side</h3>
                        <div class="value">${formatNumber(result.leftSide)}</div>
                        <p>(p-1)(p-2)/p²</p>
                    </div>
                    <div class="result-card">
                        <h3>Right Side</h3>
                        <div class="value">${formatNumber(result.rightSide)}</div>
                        <p>(1-1/(p-1)²)(1-1/p)³</p>
                    </div>
                    <div class="result-card">
                        <h3>Verification</h3>
                        <div class="value" style="color: ${result.isValid ? '#28a745' : '#dc3545'}">
                            ${result.isValid ? '✓ VALID' : '✗ INVALID'}
                        </div>
                        <p>Difference: ${formatNumber(result.difference)}</p>
                    </div>
                </div>
            `;
            document.getElementById('identityResults').innerHTML = html;
        }

        function displayStepByStep(p, leftSide, rightSide, term1, term2) {
            const html = `
                <p><strong>For p = ${p}:</strong></p>
                <p>Left side: (${p}-1)(${p}-2)/${p}² = ${p-1} × ${p-2} / ${p*p} = ${formatNumber(leftSide)}</p>
                <p>Right side breakdown:</p>
                <p>  • First term: 1 - 1/(${p}-1)² = 1 - 1/${(p-1)*(p-1)} = ${formatNumber(term1)}</p>
                <p>  • Second term: (1 - 1/${p})³ = (${formatNumber(1-1/p)})³ = ${formatNumber(term2)}</p>
                <p>  • Product: ${formatNumber(term1)} × ${formatNumber(term2)} = ${formatNumber(rightSide)}</p>
                <p><strong>Result:</strong> Both sides equal ${formatNumber(leftSide)} ✓</p>
            `;
            document.getElementById('stepByStep').innerHTML = html;
        }

        // Prime product computation
        async function computePrimeProduct() {
            const start = parseInt(document.getElementById('startPrime').value);
            const end = parseInt(document.getElementById('endPrime').value);

            if (start < 3 || end < start) {
                alert('Please enter valid prime range (start ≥ 3, end ≥ start)');
                return;
            }

            // Show progress
            document.getElementById('computeProgress').style.display = 'block';
            document.getElementById('computeStatus').textContent = 'Computing prime products...';
            document.getElementById('computeStatus').className = 'status computing';

            const primes = getPrimesUpTo(end).filter(p => p >= start);
            
            let product = 1;
            let twinProduct = 1;
            let mertensProduct = 1;
            let logSum = 0;
            let logTwinSum = 0;
            let logMertensSum = 0;

            const results = [];

            for (let i = 0; i < primes.length; i++) {
                const p = primes[i];
                
                const term = (p - 1) * (p - 2) / (p * p);
                const twinTerm = 1 - 1 / ((p - 1) * (p - 1));
                const mertensTerm = 1 - 1 / p;

                // Use logarithms for numerical stability
                logSum += Math.log(term);
                logTwinSum += Math.log(twinTerm);
                logMertensSum += Math.log(mertensTerm);

                product = Math.exp(logSum);
                twinProduct = Math.exp(logTwinSum);
                mertensProduct = Math.exp(logMertensSum);

                results.push({
                    prime: p,
                    term: term,
                    product: product,
                    twinProduct: twinProduct,
                    mertensProduct: mertensProduct,
                    mertensCubed: Math.pow(mertensProduct, 3),
                    factorization: twinProduct * Math.pow(mertensProduct, 3)
                });

                // Update progress
                const progress = ((i + 1) / primes.length) * 100;
                document.getElementById('computeProgressFill').style.width = progress + '%';
                
                // Allow UI updates
                if (i % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            currentResults.primeProduct = {
                start: start,
                end: end,
                primes: primes,
                results: results,
                finalProduct: product,
                finalTwinProduct: twinProduct,
                finalMertensProduct: mertensProduct,
                rModular: product / 4
            };

            document.getElementById('computeStatus').textContent = 'Computation complete!';
            document.getElementById('computeStatus').className = 'status complete';
            document.getElementById('computeProgress').style.display = 'none';

            displayPrimeResults();
        }

        function displayPrimeResults() {
            const result = currentResults.primeProduct;
            const final = result.results[result.results.length - 1];

            const summaryHtml = `
                <div class="results-grid">
                    <div class="result-card">
                        <h3>Prime Range</h3>
                        <div class="value">${result.start} to ${result.end}</div>
                        <p>${result.primes.length} primes found</p>
                    </div>
                    <div class="result-card">
                        <h3>Final Product</h3>
                        <div class="value">${formatNumber(result.finalProduct)}</div>
                        <p>∏(p-1)(p-2)/p²</p>
                    </div>
                    <div class="result-card">
                        <h3>Twin Factor</h3>
                        <div class="value">${formatNumber(result.finalTwinProduct)}</div>
                        <p>C_twin(${result.end})</p>
                    </div>
                    <div class="result-card">
                        <h3>Mertens³ Factor</h3>
                        <div class="value">${formatNumber(Math.pow(result.finalMertensProduct, 3))}</div>
                        <p>[M(${result.end})]³</p>
                    </div>
                    <div class="result-card">
                        <h3>Factorization Check</h3>
                        <div class="value" style="color: #28a745">✓ VERIFIED</div>
                        <p>Product = Twin × Mertens³</p>
                    </div>
                    <div class="result-card">
                        <h3>R_modular(y)</h3>
                        <div class="value">${formatNumber(result.rModular)}</div>
                        <p>Product / 4</p>
                    </div>
                </div>
            `;

            // Create detailed table
            let tableHtml = `
                <h3>Detailed Results by Prime</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Prime p</th>
                            <th>(p-1)(p-2)/p²</th>
                            <th>Running Product</th>
                            <th>Twin Factor</th>
                            <th>Mertens Factor</th>
                            <th>Verification</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            for (const row of result.results.slice(-20)) { // Show last 20 for performance
                const verification = Math.abs(row.product - row.factorization) < 1e-10 ? '✓' : '✗';
                tableHtml += `
                    <tr>
                        <td>${row.prime}</td>
                        <td>${formatNumber(row.term, 6)}</td>
                        <td>${formatNumber(row.product, 6)}</td>
                        <td>${formatNumber(row.twinProduct, 6)}</td>
                        <td>${formatNumber(row.mertensProduct, 6)}</td>
                        <td style="color: ${verification === '✓' ? '#28a745' : '#dc3545'}">${verification}</td>
                    </tr>
                `;
            }

            tableHtml += '</tbody></table>';

            document.getElementById('primeResults').innerHTML = summaryHtml + tableHtml;
        }

        // Asymptotic analysis
        async function analyzeAsymptotics() {
            const maxRange = parseInt(document.getElementById('maxRange').value);
            const numPoints = parseInt(document.getElementById('numPoints').value);

            document.getElementById('analysisProgress').style.display = 'block';
            document.getElementById('analysisStatus').textContent = 'Computing asymptotic behavior...';
            document.getElementById('analysisStatus').className = 'status computing';

            const points = [];
            const step = Math.floor(maxRange / numPoints);

            for (let i = 1; i <= numPoints; i++) {
                const y = Math.max(10, i * step);
                const primes = getPrimesUpTo(y).filter(p => p >= 3);
                
                let logSum = 0;
                let logTwinSum = 0;
                let logMertensSum = 0;

                for (const p of primes) {
                    logSum += Math.log((p - 1) * (p - 2) / (p * p));
                    logTwinSum += Math.log(1 - 1 / ((p - 1) * (p - 1)));
                    logMertensSum += Math.log(1 - 1 / p);
                }

                const product = Math.exp(logSum);
                const twinProduct = Math.exp(logTwinSum);
                const mertensProduct = Math.exp(logMertensSum);
                const rModular = product / 4;

                // Theoretical asymptotic: 2 * C2 * e^(-3γ) / (log y)^3
                const gamma = 0.5772156649015329; // Euler-Mascheroni constant
                const C2 = 0.6601618158468695; // Hardy-Littlewood twin constant (approximate)
                const theoretical = 2 * C2 * Math.exp(-3 * gamma) / Math.pow(Math.log(y), 3);

                points.push({
                    y: y,
                    numPrimes: primes.length,
                    product: product,
                    twinProduct: twinProduct,
                    mertensProduct: mertensProduct,
                    rModular: rModular,
                    theoretical: theoretical,
                    ratio: rModular / theoretical,
                    logY: Math.log(y),
                    logProduct: Math.log(rModular)
                });

                // Update progress
                const progress = (i / numPoints) * 100;
                document.getElementById('analysisProgressFill').style.width = progress + '%';
                
                // Allow UI updates
                if (i % 5 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 1));
                }
            }

            currentResults.asymptotic = {
                maxRange: maxRange,
                numPoints: numPoints,
                points: points
            };

            document.getElementById('analysisStatus').textContent = 'Analysis complete!';
            document.getElementById('analysisStatus').className = 'status complete';
            document.getElementById('analysisProgress').style.display = 'none';

            displayAsymptoticResults();
        }

        function displayAsymptoticResults() {
            const result = currentResults.asymptotic;
            const lastPoint = result.points[result.points.length - 1];

            const summaryHtml = `
                <div class="results-grid">
                    <div class="result-card">
                        <h3>Range Analyzed</h3>
                        <div class="value">3 to ${result.maxRange}</div>
                        <p>${result.numPoints} data points</p>
                    </div>
                    <div class="result-card">
                        <h3>Final R_modular</h3>
                        <div class="value">${formatNumber(lastPoint.rModular)}</div>
                        <p>At y = ${lastPoint.y}</p>
                    </div>
                    <div class="result-card">
                        <h3>Theoretical Prediction</h3>
                        <div class="value">${formatNumber(lastPoint.theoretical)}</div>
                        <p>2C₂e^(-3γ)/(log y)³</p>
                    </div>
                    <div class="result-card">
                        <h3>Ratio (Actual/Theory)</h3>
                        <div class="value">${formatNumber(lastPoint.ratio, 6)}</div>
                        <p>Convergence indicator</p>
                    </div>
                </div>
            `;

            // Create asymptotic table
            let tableHtml = `
                <h3>Asymptotic Behavior Analysis</h3>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Upper Limit y</th>
                            <th># Primes</th>
                            <th>R_modular(y)</th>
                            <th>Theoretical</th>
                            <th>Ratio</th>
                            <th>log y</th>
                            <th>(log y)³</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            for (const point of result.points) {
                const logYCubed = Math.pow(point.logY, 3);
                tableHtml += `
                    <tr>
                        <td>${point.y}</td>
                        <td>${point.numPrimes}</td>
                        <td>${formatNumber(point.rModular, 6)}</td>
                        <td>${formatNumber(point.theoretical, 6)}</td>
                        <td>${formatNumber(point.ratio, 4)}</td>
                        <td>${formatNumber(point.logY, 4)}</td>
                        <td>${formatNumber(logYCubed, 4)}</td>
                    </tr>
                `;
            }

            tableHtml += '</tbody></table>';

            document.getElementById('asymptoticResults').innerHTML = summaryHtml + tableHtml;
            
            // Show chart container
            document.getElementById('asymptoticChart').style.display = 'block';
            drawAsymptoticChart();
        }

        function drawAsymptoticChart() {
            const canvas = document.getElementById('asymptoticCanvas');
            const ctx = canvas.getContext('2d');
            const points = currentResults.asymptotic.points;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set up chart dimensions
            const padding = 60;
            const chartWidth = canvas.width - 2 * padding;
            const chartHeight = canvas.height - 2 * padding;

            // Find data ranges
            const xValues = points.map(p => p.logY);
            const yValues = points.map(p => Math.log(p.rModular));
            const theoreticalValues = points.map(p => Math.log(p.theoretical));

            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues, ...theoreticalValues);
            const yMax = Math.max(...yValues, ...theoreticalValues);

            // Helper function to convert data to canvas coordinates
            function toCanvasX(x) {
                return padding + (x - xMin) / (xMax - xMin) * chartWidth;
            }

            function toCanvasY(y) {
                return padding + (yMax - y) / (yMax - yMin) * chartHeight;
            }

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();

            // Draw actual data
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < points.length; i++) {
                const x = toCanvasX(points[i].logY);
                const y = toCanvasY(Math.log(points[i].rModular));
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw theoretical prediction
            ctx.strokeStyle = '#764ba2';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            for (let i = 0; i < points.length; i++) {
                const x = toCanvasX(points[i].logY);
                const y = toCanvasY(Math.log(points[i].theoretical));
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Add labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('log y', canvas.width / 2, canvas.height - 20);
            
            ctx.save();
            ctx.translate(20, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('log(R_modular)', 0, 0);
            ctx.restore();

            // Add legend
            ctx.fillStyle = '#667eea';
            ctx.fillRect(canvas.width - 150, 30, 20, 3);
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Actual', canvas.width - 125, 35);

            ctx.fillStyle = '#764ba2';
            ctx.fillRect(canvas.width - 150, 50, 20, 3);
            ctx.fillText('Theoretical', canvas.width - 125, 55);
        }

        // Telescoping comparison
        function compareTelescopingVsPrimes() {
            const n = parseInt(document.getElementById('comparisonN').value);

            if (n < 3) {
                alert('Please enter n ≥ 3');
                return;
            }

            // Consecutive integers telescoping
            const integerProduct = 4 / (n * n * (n - 1));
            
            // Step-by-step for integers
            let integerStepProduct = 1;
            const integerSteps = [];
            for (let k = 3; k <= n; k++) {
                const term = (k - 1) * (k - 2) / (k * k);
                integerStepProduct *= term;
                integerSteps.push({
                    k: k,
                    term: term,
                    product: integerStepProduct
                });
            }

            // Prime product (no telescoping)
            const primes = getPrimesUpTo(n).filter(p => p >= 3);
            let primeProduct = 1;
            let primeTwinProduct = 1;
            let primeMertensProduct = 1;
            const primeSteps = [];

            for (const p of primes) {
                const term = (p - 1) * (p - 2) / (p * p);
                const twinTerm = 1 - 1 / ((p - 1) * (p - 1));
                const mertensTerm = 1 - 1 / p;

                primeProduct *= term;
                primeTwinProduct *= twinTerm;
                primeMertensProduct *= mertensTerm;

                primeSteps.push({
                    p: p,
                    term: term,
                    product: primeProduct,
                    twinProduct: primeTwinProduct,
                    mertensProduct: primeMertensProduct
                });
            }

            currentResults.comparison = {
                n: n,
                integerProduct: integerProduct,
                integerStepProduct: integerStepProduct,
                integerSteps: integerSteps,
                primes: primes,
                primeProduct: primeProduct,
                primeTwinProduct: primeTwinProduct,
                primeMertensProduct: primeMertensProduct,
                primeSteps: primeSteps
            };

            displayComparisonResults();
        }

        function displayComparisonResults() {
            const result = currentResults.comparison;

            const summaryHtml = `
                <div class="comparison-grid">
                    <div class="result-card">
                        <h3>Consecutive Integers (3 to ${result.n})</h3>
                        <div class="value">${formatNumber(result.integerProduct)}</div>
                        <p><strong>Telescopes to:</strong> 4/(n²(n-1))</p>
                        <p><strong>Step-by-step product:</strong> ${formatNumber(result.integerStepProduct)}</p>
                        <p style="color: ${Math.abs(result.integerProduct - result.integerStepProduct) < 1e-12 ? '#28a745' : '#dc3545'}">
                            ${Math.abs(result.integerProduct - result.integerStepProduct) < 1e-12 ? '✓ Perfect match' : '✗ Mismatch'}
                        </p>
                    </div>
                    <div class="result-card">
                        <h3>Primes Only (up to ${result.n})</h3>
                        <div class="value">${formatNumber(result.primeProduct)}</div>
                        <p><strong>No telescoping formula</strong></p>
                        <p><strong>Primes used:</strong> ${result.primes.join(', ')}</p>
                        <p><strong>Factorization:</strong> Twin × Mertens³</p>
                    </div>
                </div>

                <div class="explanation">
                    <h3>Why the Difference?</h3>
                    <p><strong>Consecutive Integers:</strong> The product telescopes because adjacent terms like (k-1)/k cancel across consecutive values.</p>
                    <p><strong>Primes Only:</strong> Since primes skip most integers, there's no consecutive cancellation. The identity reveals the structure but doesn't telescope to a simple formula.</p>
                </div>
            `;

            // Detailed comparison table
            let tableHtml = `
                <h3>Step-by-Step Comparison</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h4>Consecutive Integers</h4>
                        <table class="data-table">
                            <thead>
                                <tr><th>k</th><th>(k-1)(k-2)/k²</th><th>Running Product</th></tr>
                            </thead>
                            <tbody>
            `;

            for (const step of result.integerSteps) {
                tableHtml += `
                    <tr>
                        <td>${step.k}</td>
                        <td>${formatNumber(step.term, 6)}</td>
                        <td>${formatNumber(step.product, 6)}</td>
                    </tr>
                `;
            }

            tableHtml += `
                            </tbody>
                        </table>
                    </div>
                    <div>
                        <h4>Primes Only</h4>
                        <table class="data-table">
                            <thead>
                                <tr><th>p</th><th>(p-1)(p-2)/p²</th><th>Running Product</th></tr>
                            </thead>
                            <tbody>
            `;

            for (const step of result.primeSteps) {
                tableHtml += `
                    <tr>
                        <td>${step.p}</td>
                        <td>${formatNumber(step.term, 6)}</td>
                        <td>${formatNumber(step.product, 6)}</td>
                    </tr>
                `;
            }

            tableHtml += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            document.getElementById('comparisonResults').innerHTML = summaryHtml + tableHtml;
        }

        // Export functionality
        function exportResults(section) {
            let data = {};
            let filename = '';

            switch (section) {
                case 'computation':
                    data = currentResults.primeProduct;
                    filename = `prime_product_${data?.start || 'unknown'}_to_${data?.end || 'unknown'}.json`;
                    break;
                case 'analysis':
                    data = currentResults.asymptotic;
                    filename = `asymptotic_analysis_${data?.maxRange || 'unknown'}.json`;
                    break;
                case 'comparison':
                    data = currentResults.comparison;
                    filename = `telescoping_comparison_n${data?.n || 'unknown'}.json`;
                    break;
                case 'theory':
                    data = {
                        title: "Prime Research Theory Summary",
                        author: "Wessen Getachew",
                        date: "Summer 2025",
                        identity: "(p-1)(p-2)/p² = (1-1/(p-1)²)(1-1/p)³",
                        applications: [
                            "Twin prime research",
                            "Sieve theory",
                            "Computational number theory",
                            "Asymptotic analysis"
                        ],
                        constants: {
                            "Hardy-Littlewood C2": 0.66016,
                            "Euler-Mascheroni gamma": 0.5772156649,
                            "e^(-gamma)": 0.56146
                        },
                        keyResults: [
                            "Identity valid for all p ≠ 0,1",
                            "Telescoping works for consecutive integers only",
                            "Prime products decay as (log y)^(-3)",
                            "Clean factorization into twin and Mertens factors"
                        ]
                    };
                    filename = 'prime_research_theory_summary.json';
                    break;
                default:
                    alert('No data to export');
                    return;
            }

            if (!data || Object.keys(data).length === 0) {
                alert('No data available to export. Please run the computation first.');
                return;
            }

            // Add metadata
            const exportData = {
                metadata: {
                    title: "Prime Research by Wessen Getachew",
                    date: new Date().toISOString(),
                    section: section,
                    identity: "(p-1)(p-2)/p² = (1-1/(p-1)²)(1-1/p)³"
                },
                data: data
            };

            // Create and download file
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            alert(`Results exported as ${filename}`);
        }

        // Initialize with identity verification for p=5
        window.onload = function() {
            document.getElementById('testValue').value = '5';
            verifyIdentity();
        };
    </script>
</body>

    
<title>Getachew Modular Twin Transition Framework</title>
    <style>
        :root {
            --primary: #2563eb;
            --secondary: #7c3aed;
            --accent: #dc2626;
            --success: #16a34a;
            --warning: #ea580c;
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 20px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(37, 99, 235, 0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .author {
            font-size: 1.1em;
            opacity: 0.8;
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .tab-button {
            padding: 12px 24px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 25px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab-button:hover {
            border-color: var(--primary);
            color: var(--text-primary);
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
        }

        .theorem {
            border-left: 4px solid var(--primary);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%);
        }

        .definition {
            border-left: 4px solid var(--secondary);
            background: linear-gradient(135deg, rgba(124, 58, 237, 0.1) 0%, rgba(124, 58, 237, 0.05) 100%);
        }

        .example {
            border-left: 4px solid var(--success);
            background: linear-gradient(135deg, rgba(22, 163, 74, 0.1) 0%, rgba(22, 163, 74, 0.05) 100%);
        }

        .formula {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            text-align: center;
            border: 1px solid var(--border);
        }

        .interactive-section {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border: 2px solid var(--primary);
        }

        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .input-group label {
            font-weight: 600;
            color: var(--text-primary);
        }

        .input-group input, .input-group select {
            padding: 10px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(37, 99, 235, 0.4);
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
            color: var(--primary);
        }

        .result {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid var(--border);
            font-family: 'Courier New', monospace;
        }

        .success { color: var(--success); }
        .warning { color: var(--warning); }
        .error { color: var(--accent); }

        .visualization {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .residue-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(40px, 1fr));
            gap: 5px;
            margin: 20px 0;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .residue-cell {
            width: 40px;
            height: 40px;
            border: 2px solid var(--border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .residue-cell.coprime {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .residue-cell.transition {
            background: var(--success);
            border-color: var(--success);
            animation: pulse 1s infinite;
        }

        .residue-cell.forbidden {
            background: var(--accent);
            border-color: var(--accent);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .transition-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .transition-pair {
            background: var(--success);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .mathematical-notation {
            font-style: italic;
            color: var(--text-secondary);
        }

        .highlight {
            background: linear-gradient(135deg, var(--warning) 0%, var(--accent) 100%);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .residue-grid {
                grid-template-columns: repeat(auto-fit, minmax(35px, 1fr));
            }
            
            .residue-cell {
                width: 35px;
                height: 35px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Getachew Modular Twin Transition Framework</h1>
            <div class="subtitle">Interactive Mathematical Explorer</div>
            <div class="author">By Wessen Getachew | Independent Researcher</div>
        </div>

        <div class="nav-tabs">
            <button class="tab-button active" onclick="showTab('theorems')">Theorems</button>
            <button class="tab-button" onclick="showTab('calculator')">Interactive Calculator</button>
            <button class="tab-button" onclick="showTab('visualizer')">Visualizer</button>
            <button class="tab-button" onclick="showTab('examples')">Worked Examples</button>
            <button class="tab-button" onclick="showTab('generalizations')">Generalizations</button>
        </div>

        <div id="theorems" class="tab-content active">
            <div class="card theorem">
                <h2>🔢 Getachew Modular Twin Transition Lift Theorem</h2>
                <p><strong>Theorem:</strong> Let <span class="mathematical-notation">M = 30·2ⁿ</span> and <span class="mathematical-notation">M' = 2M = 30·2ⁿ⁺¹</span>. If <span class="mathematical-notation">(r, r+2)</span> is a twin residue transition modulo <span class="mathematical-notation">M</span>, then <span class="mathematical-notation">(r, r+2)</span> is also a twin residue transition modulo <span class="mathematical-notation">M'</span>.</p>
                
                <div class="formula">
                    Every valid transition at level n <strong>persists</strong> to level n+1
                </div>
                
                <p><strong>Key Insight:</strong> The dyadic expansion preserves all existing twin transitions while potentially introducing new ones.</p>
            </div>

            <div class="card theorem">
                <h2>🔢 Getachew Prime Modulus Transition Law</h2>
                <p><strong>Theorem:</strong> Let <span class="mathematical-notation">p > 2</span> be prime. The number of twin residue transitions modulo <span class="mathematical-notation">p</span> equals:</p>
                
                <div class="formula">
                    T(p) = p - 2
                </div>
                
                <p><strong>Proof Sketch:</strong> All nonzero residues except <span class="mathematical-notation">p-2</span> serve as valid starting points for twin transitions.</p>
            </div>

            <div class="card definition">
                <h2>📋 Key Definitions</h2>
                <ul>
                    <li><strong>Reduced Residue System Φ(M):</strong> {r ∈ {0,1,...,M-1} : gcd(r,M) = 1}</li>
                    <li><strong>Twin Residue Transition:</strong> Ordered pair (r, r+2) with r, r+2 ∈ Φ(M)</li>
                    <li><strong>Dyadic Family:</strong> M_n = 30·2ⁿ with φ(M_n) = 8·2ⁿ</li>
                </ul>
            </div>
        </div>

        <div id="calculator" class="tab-content">
            <div class="interactive-section">
                <h2>🧮 Twin Transition Calculator</h2>
                
                <div class="input-group">
                    <label>Modulus Type:</label>
                    <select id="modulus-type">
                        <option value="dyadic">Dyadic (30·2ⁿ)</option>
                        <option value="prime">Prime</option>
                        <option value="custom">Custom</option>
                    </select>
                    
                    <label>Value (n for dyadic, p for prime, M for custom):</label>
                    <input type="number" id="modulus-value" value="0" min="0">
                    
                    <button class="btn btn-primary" onclick="calculateTransitions()">Calculate</button>
                </div>

                <div id="calculation-results" class="result" style="display: none;"></div>
            </div>

            <div class="interactive-section">
                <h2>🎯 Gap-g Transition Calculator</h2>
                
                <div class="input-group">
                    <label>Modulus M:</label>
                    <input type="number" id="gap-modulus" value="30" min="1">
                    
                    <label>Gap g (even):</label>
                    <input type="number" id="gap-value" value="2" min="2" step="2">
                    
                    <button class="btn btn-primary" onclick="calculateGapTransitions()">Calculate Gap-g Transitions</button>
                </div>

                <div id="gap-results" class="result" style="display: none;"></div>
            </div>
        </div>

        <div id="visualizer" class="tab-content">
            <div class="interactive-section">
                <h2>👁️ Residue System Visualizer</h2>
                
                <div class="input-group">
                    <label>Modulus:</label>
                    <input type="number" id="vis-modulus" value="30" min="3" max="120">
                    
                    <label>Gap:</label>
                    <input type="number" id="vis-gap" value="2" min="1" max="20">
                    
                    <button class="btn btn-primary" onclick="visualizeResidues()">Visualize</button>
                </div>

                <div class="visualization">
                    <div id="residue-display"></div>
                    <div id="transition-display"></div>
                </div>
            </div>
        </div>

        <div id="examples" class="tab-content">
            <div class="interactive-section">
                <h2>📊 Dyadic Lift Explorer</h2>
                <p>Explore how twin transitions lift from M to 2M in the dyadic family</p>
                
                <div class="input-group">
                    <label>Base Modulus M:</label>
                    <select id="lift-base-type">
                        <option value="30">30 (base case)</option>
                        <option value="60">60 = 30·2¹</option>
                        <option value="120">120 = 30·2²</option>
                        <option value="240">240 = 30·2³</option>
                        <option value="480">480 = 30·2⁴</option>
                        <option value="custom">Custom M</option>
                    </select>
                    
                    <input type="number" id="lift-custom-base" placeholder="Custom M" style="display: none;" min="1">
                    
                    <button class="btn btn-primary" onclick="runLiftExample()">Explore Dyadic Lift</button>
                </div>

                <div id="lift-results" class="result" style="display: none;"></div>
            </div>

            <div class="interactive-section">
                <h2>🎲 Prime Modulus Explorer</h2>
                <p>Verify the Prime Modulus Transition Law: T(p) = p - 2</p>
                
                <div class="input-group">
                    <label>Prime p:</label>
                    <input type="number" id="prime-input" value="5" min="3">
                    
                    <label>OR select preset:</label>
                    <select id="prime-preset">
                        <option value="">Choose prime...</option>
                        <option value="5">5</option>
                        <option value="7">7</option>
                        <option value="11">11</option>
                        <option value="13">13</option>
                        <option value="17">17</option>
                        <option value="23">23</option>
                        <option value="29">29</option>
                        <option value="37">37</option>
                        <option value="41">41</option>
                        <option value="43">43</option>
                        <option value="307">307</option>
                    </select>
                    
                    <button class="btn btn-primary" onclick="runPrimeExample()">Analyze Prime</button>
                </div>

                <div id="prime-results" class="result" style="display: none;"></div>
            </div>

            <div class="interactive-section">
                <h2>🔍 Custom Transition Explorer</h2>
                <p>Explore twin transitions for any modulus and compare with theoretical predictions</p>
                
                <div class="input-group">
                    <label>Modulus M:</label>
                    <input type="number" id="custom-modulus" value="210" min="3">
                    
                    <label>Gap g:</label>
                    <input type="number" id="custom-gap" value="2" min="1">
                    
                    <label>Show details:</label>
                    <input type="checkbox" id="show-details" checked>
                    
                    <button class="btn btn-primary" onclick="runCustomExample()">Analyze Custom Case</button>
                </div>

                <div id="custom-results" class="result" style="display: none;"></div>
            </div>

            <div class="interactive-section">
                <h2>⚡ Batch Analysis</h2>
                <p>Compare transition counts across multiple moduli</p>
                
                <div class="input-group">
                    <label>Analysis Type:</label>
                    <select id="batch-type">
                        <option value="dyadic">Dyadic sequence (30·2ⁿ)</option>
                        <option value="primes">Prime sequence</option>
                        <option value="custom">Custom sequence</option>
                    </select>
                    
                    <label>Range/Values:</label>
                    <input type="text" id="batch-range" placeholder="e.g., 0,1,2,3,4 or 5,7,11,13,17" value="0,1,2,3,4">
                    
                    <button class="btn btn-primary" onclick="runBatchAnalysis()">Run Batch Analysis</button>
                </div>

                <div id="batch-results" class="result" style="display: none;"></div>
            </div>
        </div>

        <div id="generalizations" class="tab-content">
            <div class="card theorem">
                <h2>🌟 Hardy-Getachew Modular Goldbach-Tuple Correspondence</h2>
                <p>For even-offset tuples H ⊂ 2ℤ and modulus M = 30·2ⁿ:</p>
                
                <div class="formula">
                    T_H(M) = φ(M) · ∏_{p|M, p odd} (1 - |S_p(H)|/(p-1))
                </div>
                
                <p>Where S_p(H) = {-h mod p : h ∈ H} ∩ Φ(p)</p>
            </div>

            <div class="interactive-section">
                <h2>🔬 k-Tuple Explorer</h2>
                
                <div class="input-group">
                    <label>Tuple Type:</label>
                    <select id="tuple-type">
                        <option value="twin">Twin (0,2)</option>
                        <option value="triplet">Triplet (0,2,6)</option>
                        <option value="quadruplet">Quadruplet (0,2,6,8)</option>
                        <option value="custom">Custom</option>
                    </select>
                    
                    <label>Custom offsets (comma-separated, even only):</label>
                    <input type="text" id="custom-offsets" placeholder="0,2,6" disabled>
                    
                    <label>Modulus:</label>
                    <input type="number" id="tuple-modulus" value="30" min="1">
                    
                    <button class="btn btn-primary" onclick="calculateTuple()">Calculate k-Tuple</button>
                </div>

                <div id="tuple-results" class="result" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        // Tab management
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Mathematical utilities
        function gcd(a, b) {
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function eulerPhi(n) {
            let result = n;
            for (let p = 2; p * p <= n; p++) {
                if (n % p === 0) {
                    while (n % p === 0) n /= p;
                    result -= result / p;
                }
            }
            if (n > 1) result -= result / n;
            return Math.floor(result);
        }

        function getReducedResidueSystem(m) {
            const residues = [];
            for (let r = 1; r < m; r++) {
                if (gcd(r, m) === 1) {
                    residues.push(r);
                }
            }
            return residues;
        }

        function getTwinTransitions(m) {
            const phi_m = getReducedResidueSystem(m);
            const transitions = [];
            
            for (const r of phi_m) {
                const r_plus_2 = (r + 2) % m;
                if (phi_m.includes(r_plus_2)) {
                    transitions.push([r, r_plus_2]);
                }
            }
            return transitions;
        }

        function getGapTransitions(m, gap) {
            const phi_m = getReducedResidueSystem(m);
            const transitions = [];
            
            for (const r of phi_m) {
                const r_plus_gap = (r + gap) % m;
                if (phi_m.includes(r_plus_gap)) {
                    transitions.push([r, r_plus_gap]);
                }
            }
            return transitions;
        }

        function isPrime(n) {
            if (n < 2) return false;
            for (let i = 2; i * i <= n; i++) {
                if (n % i === 0) return false;
            }
            return true;
        }

        // Calculator functions
        function calculateTransitions() {
            const type = document.getElementById('modulus-type').value;
            const value = parseInt(document.getElementById('modulus-value').value);
            const resultsDiv = document.getElementById('calculation-results');
            
            let modulus;
            let result = '';
            
            if (type === 'dyadic') {
                modulus = 30 * Math.pow(2, value);
                result += `<h3>Dyadic Modulus: M_${value} = 30·2^${value} = ${modulus}</h3>`;
                result += `<p>φ(${modulus}) = 8·2^${value} = ${8 * Math.pow(2, value)}</p>`;
            } else if (type === 'prime') {
                if (!isPrime(value)) {
                    result = `<p class="error">Error: ${value} is not prime!</p>`;
                    resultsDiv.innerHTML = result;
                    resultsDiv.style.display = 'block';
                    return;
                }
                modulus = value;
                result += `<h3>Prime Modulus: p = ${modulus}</h3>`;
                result += `<p>T(${modulus}) = ${modulus} - 2 = ${modulus - 2}</p>`;
            } else {
                modulus = value;
                result += `<h3>Custom Modulus: M = ${modulus}</h3>`;
                result += `<p>φ(${modulus}) = ${eulerPhi(modulus)}</p>`;
            }
            
            const transitions = getTwinTransitions(modulus);
            result += `<p class="success">Number of twin transitions: <strong>${transitions.length}</strong></p>`;
            
            if (transitions.length > 0 && transitions.length <= 20) {
                result += `<p>Transitions: `;
                result += transitions.map(t => `(${t[0]},${t[1]})`).join(', ');
                result += `</p>`;
            }
            
            resultsDiv.innerHTML = result;
            resultsDiv.style.display = 'block';
        }

        function calculateGapTransitions() {
            const modulus = parseInt(document.getElementById('gap-modulus').value);
            const gap = parseInt(document.getElementById('gap-value').value);
            const resultsDiv = document.getElementById('gap-results');
            
            if (gap % 2 !== 0) {
                resultsDiv.innerHTML = `<p class="error">Gap must be even!</p>`;
                resultsDiv.style.display = 'block';
                return;
            }
            
            const transitions = getGapTransitions(modulus, gap);
            
            let result = `<h3>Gap-${gap} Transitions for M = ${modulus}</h3>`;
            result += `<p>φ(${modulus}) = ${eulerPhi(modulus)}</p>`;
            result += `<p class="success">Number of gap-${gap} transitions: <strong>${transitions.length}</strong></p>`;
            
            if (transitions.length > 0 && transitions.length <= 20) {
                result += `<div class="transition-list">`;
                result += transitions.map(t => `<span class="transition-pair">(${t[0]},${t[1]})</span>`).join('');
                result += `</div>`;
            }
            
            resultsDiv.innerHTML = result;
            resultsDiv.style.display = 'block';
        }

        // Visualizer functions
        function visualizeResidues() {
            const modulus = parseInt(document.getElementById('vis-modulus').value);
            const gap = parseInt(document.getElementById('vis-gap').value);
            const displayDiv = document.getElementById('residue-display');
            const transitionDiv = document.getElementById('transition-display');
            
            const phi_m = getReducedResidueSystem(modulus);
            const transitions = getGapTransitions(modulus, gap);
            const transitionStarts = new Set(transitions.map(t => t[0]));
            
            let html = `<h3>Φ(${modulus}) - Reduced Residue System</h3>`;
            html += `<div class="residue-grid">`;
            
            for (let i = 0; i < modulus && i < 60; i++) { // Limit display for performance
                const isCoprime = phi_m.includes(i);
                const isTransition = transitionStarts.has(i);
                let className = 'residue-cell';
                
                if (isTransition) {
                    className += ' transition';
                } else if (isCoprime) {
                    className += ' coprime';
                }
                
                html += `<div class="${className}">${i}</div>`;
            }
            
            if (modulus > 60) {
                html += `<div class="residue-cell" style="border: none; background: none;">...</div>`;
            }
            
            html += `</div>`;
            displayDiv.innerHTML = html;
            
            let transitionHtml = `<h4>Gap-${gap} Transitions (${transitions.length} total)</h4>`;
            if (transitions.length <= 15) {
                transitionHtml += `<div class="transition-list">`;
                transitionHtml += transitions.map(t => `<span class="transition-pair">(${t[0]},${t[1]})</span>`).join('');
                transitionHtml += `</div>`;
            } else {
                transitionHtml += `<p>Too many transitions to display (${transitions.length} total)</p>`;
            }
            
            transitionDiv.innerHTML = transitionHtml;
        }

        // Enhanced example functions with user input
        function runLiftExample() {
            const baseType = document.getElementById('lift-base-type').value;
            const customBase = document.getElementById('lift-custom-base').value;
            const resultsDiv = document.getElementById('lift-results');
            
            let baseModulus;
            if (baseType === 'custom') {
                baseModulus = parseInt(customBase);
                if (!baseModulus || baseModulus < 1) {
                    resultsDiv.innerHTML = `<p class="error">Please enter a valid custom modulus!</p>`;
                    resultsDiv.style.display = 'block';
                    return;
                }
            } else {
                baseModulus = parseInt(baseType);
            }
            
            const liftModulus = 2 * baseModulus;
            
            // Calculate transitions for both moduli
            const baseTransitions = getTwinTransitions(baseModulus);
            const liftTransitions = getTwinTransitions(liftModulus);
            const basePhi = getReducedResidueSystem(baseModulus);
            const liftPhi = getReducedResidueSystem(liftModulus);
            
            // Check which base transitions persist
            const persistingTransitions = [];
            const baseTransitionSet = new Set(baseTransitions.map(t => `${t[0]},${t[1]}`));
            
            for (const transition of baseTransitions) {
                const [r, r_plus_2] = transition;
                // Check if both residues are still coprime in the lift
                if (liftPhi.includes(r) && liftPhi.includes(r_plus_2)) {
                    persistingTransitions.push(transition);
                }
            }
            
            // Find new transitions in the lift
            const newTransitions = liftTransitions.filter(t => 
                !baseTransitionSet.has(`${t[0]},${t[1]}`)
            );
            
            let result = `<h3>Dyadic Lift Analysis: M = ${baseModulus} → M' = ${liftModulus}</h3>`;
            
            // Base modulus analysis
            result += `<h4>Base Modulus M = ${baseModulus}:</h4>`;
            result += `<p>Φ(${baseModulus}) = {${basePhi.slice(0, 20).join(', ')}${basePhi.length > 20 ? '...' : ''}}</p>`;
            result += `<p>φ(${baseModulus}) = ${basePhi.length}</p>`;
            result += `<p>Twin transitions: ${baseTransitions.length}</p>`;
            
            if (baseTransitions.length <= 15) {
                result += `<div class="transition-list">`;
                result += baseTransitions.map(t => `<span class="transition-pair">(${t[0]},${t[1]})</span>`).join('');
                result += `</div>`;
            }
            
            // Lift modulus analysis
            result += `<h4>Lift Modulus M' = ${liftModulus}:</h4>`;
            result += `<p>φ(${liftModulus}) = ${liftPhi.length}</p>`;
            result += `<p>Twin transitions: ${liftTransitions.length}</p>`;
            
            // Persistence analysis
            result += `<h4>Lift Persistence Analysis:</h4>`;
            result += `<p class="success">Persisting transitions: <strong>${persistingTransitions.length}/${baseTransitions.length}</strong></p>`;
            
            if (persistingTransitions.length === baseTransitions.length) {
                result += `<p class="success">✓ ALL base transitions persist! (Theorem verified)</p>`;
            } else {
                result += `<p class="error">✗ Some transitions do not persist (unexpected!)</p>`;
            }
            
            if (newTransitions.length > 0) {
                result += `<p class="warning">New transitions at lift level: <strong>${newTransitions.length}</strong></p>`;
                if (newTransitions.length <= 10) {
                    result += `<div class="transition-list">`;
                    result += newTransitions.map(t => `<span class="transition-pair" style="background: var(--warning);">(${t[0]},${t[1]})</span>`).join('');
                    result += `</div>`;
                }
            }
            
            // Theoretical verification for dyadic family
            if (baseModulus % 30 === 0 && (baseModulus / 30 & (baseModulus / 30 - 1)) === 0) {
                const n = Math.log2(baseModulus / 30);
                result += `<h4>Dyadic Family Verification:</h4>`;
                result += `<p>M = 30·2^${n}, M' = 30·2^${n+1}</p>`;
                result += `<p>φ(M) = 8·2^${n} = ${8 * Math.pow(2, n)} ✓</p>`;
                result += `<p>φ(M') = 8·2^${n+1} = ${8 * Math.pow(2, n+1)} ✓</p>`;
            }
            
            resultsDiv.innerHTML = result;
            resultsDiv.style.display = 'block';
        }

        function runPrimeExample() {
            let prime = parseInt(document.getElementById('prime-input').value);
            const preset = document.getElementById('prime-preset').value;
            const resultsDiv = document.getElementById('prime-results');
            
            if (preset) {
                prime = parseInt(preset);
                document.getElementById('prime-input').value = prime;
            }
            
            if (!isPrime(prime)) {
                resultsDiv.innerHTML = `<p class="error">${prime} is not prime! Please enter a prime number.</p>`;
                resultsDiv.style.display = 'block';
                return;
            }
            
            const transitions = getTwinTransitions(prime);
            const phi_p = getReducedResidueSystem(prime);
            const forbidden = prime - 2;
            
            let result = `<h3>Prime Modulus Analysis: p = ${prime}</h3>`;
            
            // Theorem verification
            result += `<h4>Getachew Prime Modulus Transition Law:</h4>`;
            result += `<p>Theoretical: T(${prime}) = ${prime} - 2 = <strong>${prime - 2}</strong></p>`;
            result += `<p>Actual: T(${prime}) = <strong>${transitions.length}</strong></p>`;
            
            if (transitions.length === prime - 2) {
                result += `<p class="success">✓ Theorem verified!</p>`;
            } else {
                result += `<p class="error">✗ Theorem not verified (unexpected!)</p>`;
            }
            
            // Detailed analysis
            result += `<h4>Detailed Analysis:</h4>`;
            result += `<p>Φ(${prime}) = {1, 2, 3, ..., ${prime-1}} (all nonzero residues)</p>`;
            result += `<p>Forbidden starting residue: r ≡ -2 ≡ <strong>${forbidden}</strong> (mod ${prime})</p>`;
            result += `<p>Valid starting residues: ${prime-1} - 1 = <strong>${prime-2}</strong></p>`;
            
            // Show transitions for smaller primes
            if (prime <= 23) {
                result += `<h4>All Twin Transitions:</h4>`;
                result += `<div class="transition-list">`;
                result += transitions.map(t => `<span class="transition-pair">(${t[0]},${t[1]})</span>`).join('');
                result += `</div>`;
                
                result += `<h4>Verification Details:</h4>`;
                const validStarts = transitions.map(t => t[0]).sort((a,b) => a-b);
                const allNonZero = Array.from({length: prime-1}, (_, i) => i + 1);
                const excludedStarts = allNonZero.filter(r => !validStarts.includes(r));
                
                result += `<p>Valid starts: {${validStarts.join(', ')}}</p>`;
                result += `<p>Excluded start: {${excludedStarts.join(', ')}} = {${forbidden}}</p>`;
            } else {
                result += `<p>Transition count too large to display individually (${transitions.length} transitions)</p>`;
                result += `<p>Sample transitions: ${transitions.slice(0, 5).map(t => `(${t[0]},${t[1]})`).join(', ')}...</p>`;
            }
            
            resultsDiv.innerHTML = result;
            resultsDiv.style.display = 'block';
        }

        function runCustomExample() {
            const modulus = parseInt(document.getElementById('custom-modulus').value);
            const gap = parseInt(document.getElementById('custom-gap').value);
            const showDetails = document.getElementById('show-details').checked;
            const resultsDiv = document.getElementById('custom-results');
            
            if (modulus < 1 || gap < 1) {
                resultsDiv.innerHTML = `<p class="error">Please enter valid positive integers!</p>`;
                resultsDiv.style.display = 'block';
                return;
            }
            
            const phi_m = getReducedResidueSystem(modulus);
            const transitions = getGapTransitions(modulus, gap);
            
            let result = `<h3>Custom Analysis: Gap-${gap} Transitions mod ${modulus}</h3>`;
            
            // Basic statistics
            result += `<h4>Basic Statistics:</h4>`;
            result += `<p>φ(${modulus}) = ${phi_m.length}</p>`;
            result += `<p>Gap-${gap} transitions: <strong>${transitions.length}</strong></p>`;
            
            if (phi_m.length > 0) {
                const density = (transitions.length / phi_m.length * 100).toFixed(2);
                result += `<p>Transition density: ${density}%</p>`;
            }
            
            // Prime factorization and theoretical analysis
            const primeFactors = getPrimeFactors(modulus);
            result += `<h4>Modulus Analysis:</h4>`;
            result += `<p>Prime factorization: ${modulus} = ${formatPrimeFactorization(primeFactors)}</p>`;
            
            // Check if it's in dyadic family
            if (modulus % 30 === 0) {
                const quotient = modulus / 30;
                if ((quotient & (quotient - 1)) === 0) { // Check if power of 2
                    const n = Math.log2(quotient);
                    result += `<p class="success">✓ Dyadic family member: M = 30·2^${n}</p>`;
                    
                    // Theoretical prediction for twins (gap = 2)
                    if (gap === 2) {
                        const theoretical = Math.floor(phi_m.length * 3/8);
                        result += `<p>Theoretical twin count: ${theoretical}</p>`;
                        result += `<p>Match: ${theoretical === transitions.length ? '✓' : '✗'}</p>`;
                    }
                }
            }
            
            // Show details if requested
            if (showDetails) {
                result += `<h4>Detailed Results:</h4>`;
                
                if (phi_m.length <= 50) {
                    result += `<p>Φ(${modulus}) = {${phi_m.join(', ')}}</p>`;
                } else {
                    result += `<p>Φ(${modulus}) = {${phi_m.slice(0, 20).join(', ')}, ..., ${phi_m.slice(-5).join(', ')}} (${phi_m.length} total)</p>`;
                }
                
                if (transitions.length <= 20) {
                    result += `<div class="transition-list">`;
                    result += transitions.map(t => `<span class="transition-pair">(${t[0]},${t[1]})</span>`).join('');
                    result += `</div>`;
                } else {
                    result += `<p>Sample transitions: ${transitions.slice(0, 10).map(t => `(${t[0]},${t[1]})`).join(', ')}...</p>`;
                }
            }
            
            resultsDiv.innerHTML = result;
            resultsDiv.style.display = 'block';
        }

        function runBatchAnalysis() {
            const batchType = document.getElementById('batch-type').value;
            const rangeInput = document.getElementById('batch-range').value;
            const resultsDiv = document.getElementById('batch-results');
            
            let values;
            try {
                values = rangeInput.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
            } catch (e) {
                resultsDiv.innerHTML = `<p class="error">Invalid input format! Use comma-separated numbers.</p>`;
                resultsDiv.style.display = 'block';
                return;
            }
            
            if (values.length === 0) {
                resultsDiv.innerHTML = `<p class="error">Please enter valid numbers!</p>`;
                resultsDiv.style.display = 'block';
                return;
            }
            
            let moduli = [];
            let title = '';
            
            if (batchType === 'dyadic') {
                moduli = values.map(n => 30 * Math.pow(2, n));
                title = 'Dyadic Sequence Analysis (30·2ⁿ)';
            } else if (batchType === 'primes') {
                moduli = values.filter(isPrime);
                title = 'Prime Sequence Analysis';
                if (moduli.length < values.length) {
                    title += ` (filtered ${values.length - moduli.length} non-primes)`;
                }
            } else {
                moduli = values;
                title = 'Custom Sequence Analysis';
            }
            
            let result = `<h3>${title}</h3>`;
            result += `<div style="overflow-x: auto;">`;
            result += `<table style="width: 100%; border-collapse: collapse; margin: 20px 0;">`;
            result += `<tr style="background: var(--bg-secondary); border-bottom: 2px solid var(--border);">`;
            result += `<th style="padding: 10px; text-align: left;">Modulus</th>`;
            result += `<th style="padding: 10px; text-align: right;">φ(M)</th>`;
            result += `<th style="padding: 10px; text-align: right;">T(M)</th>`;
            result += `<th style="padding: 10px; text-align: right;">Density</th>`;
            if (batchType === 'primes') {
                result += `<th style="padding: 10px; text-align: right;">Theory</th>`;
                result += `<th style="padding: 10px; text-align: center;">Match</th>`;
            }
            result += `</tr>`;
            
            for (const m of moduli.slice(0, 15)) { // Limit for performance
                const phi = eulerPhi(m);
                const transitions = getTwinTransitions(m);
                const density = phi > 0 ? (transitions.length / phi * 100).toFixed(1) : '0';
                
                result += `<tr style="border-bottom: 1px solid var(--border);">`;
                result += `<td style="padding: 8px;"><strong>${m}</strong></td>`;
                result += `<td style="padding: 8px; text-align: right;">${phi}</td>`;
                result += `<td style="padding: 8px; text-align: right;">${transitions.length}</td>`;
                result += `<td style="padding: 8px; text-align: right;">${density}%</td>`;
                
                if (batchType === 'primes') {
                    const theory = m - 2;
                    const match = transitions.length === theory;
                    result += `<td style="padding: 8px; text-align: right;">${theory}</td>`;
                    result += `<td style="padding: 8px; text-align: center;">${match ? '✓' : '✗'}</td>`;
                }
                result += `</tr>`;
            }
            
            if (moduli.length > 15) {
                result += `<tr><td colspan="${batchType === 'primes' ? '6' : '4'}" style="padding: 8px; text-align: center; font-style: italic;">... and ${moduli.length - 15} more</td></tr>`;
            }
            
            result += `</table></div>`;
            
            resultsDiv.innerHTML = result;
            resultsDiv.style.display = 'block';
        }

        // Utility functions for batch analysis
        function getPrimeFactors(n) {
            const factors = {};
            let d = 2;
            while (d * d <= n) {
                while (n % d === 0) {
                    factors[d] = (factors[d] || 0) + 1;
                    n /= d;
                }
                d++;
            }
            if (n > 1) {
                factors[n] = (factors[n] || 0) + 1;
            }
            return factors;
        }

        function formatPrimeFactorization(factors) {
            return Object.entries(factors)
                .map(([p, e]) => e === 1 ? p : `${p}^${e}`)
                .join(' × ');
        }

        // Handle dynamic input visibility
        document.getElementById('lift-base-type').addEventListener('change', function() {
            const customInput = document.getElementById('lift-custom-base');
            if (this.value === 'custom') {
                customInput.style.display = 'inline-block';
            } else {
                customInput.style.display = 'none';
            }
        });

        document.getElementById('prime-preset').addEventListener('change', function() {
            if (this.value) {
                document.getElementById('prime-input').value = this.value;
            }
        });

        // k-tuple functions
        function calculateTuple() {
            const type = document.getElementById('tuple-type').value;
            const modulus = parseInt(document.getElementById('tuple-modulus').value);
            const resultsDiv = document.getElementById('tuple-results');
            
            let offsets;
            if (type === 'twin') offsets = [0, 2];
            else if (type === 'triplet') offsets = [0, 2, 6];
            else if (type === 'quadruplet') offsets = [0, 2, 6, 8];
            else {
                const customInput = document.getElementById('custom-offsets').value;
                offsets = customInput.split(',').map(x => parseInt(x.trim()));
                if (offsets.some(x => x % 2 !== 0)) {
                    resultsDiv.innerHTML = `<p class="error">All offsets must be even!</p>`;
                    resultsDiv.style.display = 'block';
                    return;
                }
            }
            
            const phi_m = getReducedResidueSystem(modulus);
            const validStarts = [];
            
            for (const r of phi_m) {
                let isValid = true;
                for (const h of offsets) {
                    const target = (r + h) % modulus;
                    if (!phi_m.includes(target)) {
                        isValid = false;
                        break;
                    }
                }
                if (isValid) {
                    validStarts.push(r);
                }
            }
            
            let result = `<h3>${type.charAt(0).toUpperCase() + type.slice(1)} Analysis for M = ${modulus}</h3>`;
            result += `<p>Offsets H = {${offsets.join(', ')}}</p>`;
            result += `<p>φ(${modulus}) = ${phi_m.length}</p>`;
            result += `<p class="success">Valid starting residues: <strong>${validStarts.length}</strong></p>`;
            
            if (validStarts.length > 0 && validStarts.length <= 10) {
                result += `<p>Valid starts: {${validStarts.join(', ')}}</p>`;
                result += `<h4>Realized Tuples:</h4>`;
                for (const r of validStarts.slice(0, 5)) {
                    const tuple = offsets.map(h => (r + h) % modulus);
                    result += `<p>r = ${r} → {${tuple.join(', ')}}</p>`;
                }
                if (validStarts.length > 5) {
                    result += `<p>... and ${validStarts.length - 5} more</p>`;
                }
            }
            
            // Calculate theoretical count for dyadic moduli
            if (modulus === 30 || (modulus % 30 === 0 && (modulus / 30 & (modulus / 30 - 1)) === 0)) {
                result += `<h4>Theoretical Analysis:</h4>`;
                let theoreticalFactor = 1;
                
                // Check restrictions mod 3 and 5
                for (const p of [3, 5]) {
                    const forbidden = new Set();
                    for (const h of offsets) {
                        const neg_h = (-h + p) % p;
                        if (neg_h !== 0) forbidden.add(neg_h);
                    }
                    if (forbidden.size > 0) {
                        theoreticalFactor *= (1 - forbidden.size / (p - 1));
                        result += `<p>Mod ${p} restriction: ${forbidden.size}/${p-1} forbidden → factor ${(1 - forbidden.size / (p - 1)).toFixed(3)}</p>`;
                    }
                }
                
                const theoretical = Math.floor(eulerPhi(modulus) * theoreticalFactor);
                result += `<p class="highlight">Theoretical count: ${theoretical} (matches: ${theoretical === validStarts.length ? '✓' : '✗'})</p>`;
            }
            
            resultsDiv.innerHTML = result;
            resultsDiv.style.display = 'block';
        }

        // Enable/disable custom offsets input
        document.getElementById('tuple-type').addEventListener('change', function() {
            const customInput = document.getElementById('custom-offsets');
            if (this.value === 'custom') {
                customInput.disabled = false;
                customInput.style.opacity = '1';
            } else {
                customInput.disabled = true;
                customInput.style.opacity = '0.5';
            }
        });

        // Initialize with default calculation
        document.addEventListener('DOMContentLoaded', function() {
            calculateTransitions();
        });

        // Add some interactive hover effects
        document.addEventListener('DOMContentLoaded', function() {
            // Add formula hover effects
            const formulas = document.querySelectorAll('.formula');
            formulas.forEach(formula => {
                formula.addEventListener('mouseenter', function() {
                    this.style.transform = 'scale(1.02)';
                    this.style.boxShadow = '0 8px 25px rgba(37, 99, 235, 0.3)';
                });
                formula.addEventListener('mouseleave', function() {
                    this.style.transform = 'scale(1)';
                    this.style.boxShadow = 'none';
                });
            });

            // Add card interaction effects
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.borderColor = 'var(--primary)';
                });
                card.addEventListener('mouseleave', function() {
                    this.style.borderColor = 'var(--border)';
                });
            });
        });

        // Advanced visualization for large moduli
        function createResidueVisualization(modulus, maxDisplay = 100) {
            const phi_m = getReducedResidueSystem(modulus);
            const canvas = document.createElement('canvas');
            canvas.width = 600;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            // Create circular visualization for larger moduli
            if (modulus > maxDisplay) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 150;
                
                ctx.fillStyle = '#1e293b';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw circle
                ctx.strokeStyle = '#475569';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Plot coprime residues
                phi_m.forEach(r => {
                    const angle = (2 * Math.PI * r) / modulus;
                    const x = centerX + radius * Math.cos(angle - Math.PI / 2);
                    const y = centerY + radius * Math.sin(angle - Math.PI / 2);
                    
                    ctx.fillStyle = '#2563eb';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Add title
                ctx.fillStyle = '#f8fafc';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Φ(${modulus}) - Circular Representation`, centerX, 30);
                ctx.fillText(`${phi_m.length} coprime residues`, centerX, 50);
                
                return canvas;
            }
            
            return null;
        }

        // Enhanced visualizer for larger moduli
        function visualizeResiduesAdvanced() {
            const modulus = parseInt(document.getElementById('vis-modulus').value);
            const gap = parseInt(document.getElementById('vis-gap').value);
            const displayDiv = document.getElementById('residue-display');
            
            if (modulus > 60) {
                const canvas = createResidueVisualization(modulus);
                if (canvas) {
                    displayDiv.innerHTML = '<h3>Advanced Visualization</h3>';
                    displayDiv.appendChild(canvas);
                    
                    const phi_m = getReducedResidueSystem(modulus);
                    const transitions = getGapTransitions(modulus, gap);
                    
                    const info = document.createElement('div');
                    info.innerHTML = `
                        <p>Modulus: ${modulus}</p>
                        <p>φ(${modulus}) = ${phi_m.length}</p>
                        <p>Gap-${gap} transitions: ${transitions.length}</p>
                    `;
                    displayDiv.appendChild(info);
                    return;
                }
            }
            
            // Fall back to grid visualization for smaller moduli
            visualizeResidues();
        }

        // Add keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case '1':
                        e.preventDefault();
                        showTab('theorems');
                        break;
                    case '2':
                        e.preventDefault();
                        showTab('calculator');
                        break;
                    case '3':
                        e.preventDefault();
                        showTab('visualizer');
                        break;
                    case '4':
                        e.preventDefault();
                        showTab('examples');
                        break;
                    case '5':
                        e.preventDefault();
                        showTab('generalizations');
                        break;
                }
            }
        });

        // Add tooltips for mathematical terms
        function addTooltips() {
            const mathematicalTerms = document.querySelectorAll('.mathematical-notation');
            mathematicalTerms.forEach(term => {
                term.style.cursor = 'help';
                term.title = getTooltipText(term.textContent);
            });
        }

        function getTooltipText(term) {
            const tooltips = {
                'M = 30·2ⁿ': 'Dyadic modulus family - powers of 2 times 30',
                'Φ(M)': 'Reduced residue system - integers coprime to M',
                '(r, r+2)': 'Twin residue pair with gap of 2',
                'φ(M)': 'Euler\'s totient function - count of integers ≤ M coprime to M',
                'T(p) = p - 2': 'Number of twin transitions for prime modulus p'
            };
            return tooltips[term] || 'Mathematical notation';
        }

        // Initialize tooltips when page loads
        document.addEventListener('DOMContentLoaded', addTooltips);

        // Add export functionality for results
        function exportResults(elementId, filename) {
            const element = document.getElementById(elementId);
            if (element && element.style.display !== 'none') {
                const text = element.textContent;
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Performance optimization for large calculations
        function calculateTransitionsOptimized(modulus, maxTransitions = 1000) {
            if (modulus > 1000) {
                // For very large moduli, estimate using theoretical formulas
                return estimateTransitionCount(modulus);
            }
            return getTwinTransitions(modulus);
        }

        function estimateTransitionCount(modulus) {
            // Use Hardy-Littlewood type estimation for large moduli
            const phi = eulerPhi(modulus);
            let density = 1;
            
            // Account for local restrictions at small primes
            for (let p = 3; p <= Math.min(modulus, 100); p++) {
                if (isPrime(p) && modulus % p === 0) {
                    density *= (1 - 1/(p-1));
                }
            }
            
            return Math.floor(phi * density);
        }
    </script>
</body>
                        </html>


