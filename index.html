<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Riemann Hypothesis Tester</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(30, 30, 45, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            text-align: center;
            color: #a0a0a0;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(40, 40, 60, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #4ecdc4;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #c0c0c0;
        }
        
        input, select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            box-sizing: border-box;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.1);
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .preset-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px 12px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            margin-top: 0;
            width: auto;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .results {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .results h3 {
            margin-top: 0;
            color: #4ecdc4;
            border-bottom: 2px solid #4ecdc4;
            padding-bottom: 10px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(20, 20, 30, 0.5);
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
        }
        
        .metric-label {
            font-weight: 500;
            color: #c0c0c0;
        }
        
        .metric-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
        }
        
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .status.computing {
            background: rgba(255, 243, 205, 0.2);
            color: #feca57;
            border: 1px solid #feca57;
        }
        
        .status.complete {
            background: rgba(209, 236, 241, 0.2);
            color: #4ecdc4;
            border: 1px solid #4ecdc4;
        }

        .cosmic-status {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border: 2px solid;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-cosmic {
            background: linear-gradient(45deg, rgba(255, 107, 107, 0.2), rgba(238, 90, 82, 0.2));
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .status-legendary {
            background: linear-gradient(45deg, rgba(255, 154, 86, 0.2), rgba(255, 123, 123, 0.2));
            border-color: #ff9a56;
            color: #ff9a56;
        }

        .status-mythical {
            background: linear-gradient(45deg, rgba(78, 205, 196, 0.2), rgba(68, 160, 141, 0.2));
            border-color: #4ecdc4;
            color: #4ecdc4;
        }

        .status-excellent {
            background: linear-gradient(45deg, rgba(150, 206, 180, 0.2), rgba(68, 160, 141, 0.2));
            border-color: #96ceb4;
            color: #96ceb4;
        }

        .status-good {
            background: linear-gradient(45deg, rgba(254, 202, 87, 0.2), rgba(255, 159, 67, 0.2));
            border-color: #feca57;
            color: #feca57;
        }

        .status-high {
            background: linear-gradient(45deg, rgba(255, 154, 86, 0.2), rgba(255, 107, 107, 0.2));
            border-color: #ff9a56;
            color: #ff9a56;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .visualization-item {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .visualization-item h4 {
            color: #4ecdc4;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        canvas {
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        
        .computing-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #4ecdc4;
            border-radius: 50%;
            animation: pulse 1s infinite;
            margin-left: 5px;
        }
        
        .chart-info {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #4ecdc4;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            min-height: 60px;
        }
        
        .chart-info-title {
            color: #4ecdc4;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .chart-tooltip {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #4ecdc4;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 200px;
        }
        
        .theory-box {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1));
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #4ecdc4;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        
        .theory-box h4 {
            margin-top: 0;
            color: #4ecdc4;
        }

        .detailed-results {
            margin-top: 20px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .results-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #c0c0c0;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 0;
            width: auto;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border-color: #4ecdc4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .top-results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .top-results-table th,
        .top-results-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        .top-results-table th {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        .insights {
            background: rgba(78, 205, 196, 0.1);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #4ecdc4;
        }

        .heatmap-container {
            text-align: center;
            margin: 20px 0;
        }

        .heatmap-legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .statistics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(20, 20, 30, 0.8);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #4ecdc4;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #45b7d1, #96ceb4);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin-top: 0;
            width: auto;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(69, 183, 209, 0.4);
        }
        
        @keyframes computing {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .computing button {
            animation: computing 2s infinite;
        }

        small {
            color: #a0a0a0;
            font-size: 12px;
            display: block;
            margin-top: 5px;
        }

        .advanced-options {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .performance-indicator {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid;
        }

        .perf-excellent {
            background: rgba(78, 205, 196, 0.1);
            border-color: #4ecdc4;
            color: #4ecdc4;
        }

        .perf-good {
            background: rgba(150, 206, 180, 0.1);
            border-color: #96ceb4;
            color: #96ceb4;
        }

        .perf-warning {
            background: rgba(254, 202, 87, 0.1);
            border-color: #feca57;
            color: #feca57;
        }

        .perf-danger {
            background: rgba(255, 107, 107, 0.1);
            border-color: #ff6b6b;
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🌌 Enhanced Cosmic Scale Riemann Hypothesis Tester</h1>
        <p class="subtitle">Advanced Browser-Based Computational Testing with Comprehensive Analysis - Up to 100 Million Points</p>
        
        <div class="theory-box">
            <h4>The Riemann Hypothesis - One of Mathematics' Greatest Mysteries</h4>
            <p>The Riemann Hypothesis, proposed by Bernhard Riemann in 1859, is one of the most important unsolved problems in mathematics. It concerns the distribution of prime numbers and has profound implications for number theory, cryptography, and our understanding of mathematical patterns.</p>
            
            <div class="math-formula">
                S(N,α) = Σ<sub>n≤N</sub> μ(n) · e<sup>2πinα</sup>
            <div class="theory-box">
            <h4>🌀 The Riemann Zeta Function and Its Critical Zeros</h4>
            
            <div style="background: rgba(69, 183, 209, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h5 style="color: #45b7d1; margin-top: 0;">The Zeta Function Defined</h5>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 16px; margin: 15px 0;">
                    ζ(s) = Σ<sub>n=1</sub><sup>∞</sup> 1/n<sup>s</sup> = 1 + 1/2<sup>s</sup> + 1/3<sup>s</sup> + 1/4<sup>s</sup> + ...
                <div class="theory-box">
            <h4>Enhanced by Wessen Getachew</h4>
            <p><strong>Creator:</strong> Wessen Getachew (<a href="https://twitter.com/7dview" target="_blank" style="color: #4ecdc4;">@7dview</a>)</p>
            <p><strong>Mathematical Framework:</strong> Based on classical work by Davenport, Halberstam, Montgomery, and modern computational number theory</p>
            <p><strong>Implementation:</strong> Advanced JavaScript algorithms with comprehensive visualization and interactive analysis for browser-based scientific computing</p>
            <p><strong>Special thanks to:</strong> The open mathematics community, Andrew Odlyzko's computational work, Xavier Gourdon's large-scale verifications, and all researchers who have contributed to our understanding of the Riemann Hypothesis</p>
        </div>
                <p style="margin: 10px 0; font-size: 13px;">Where <strong>s = σ + it</strong> is a complex number with real part σ and imaginary part t</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">For Real s > 1:</h6>
                        <p style="margin: 0; font-size: 12px;">Series converges absolutely<br>ζ(2) = π²/6, ζ(4) = π⁴/90</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">For σ < 1:</h6>
                        <p style="margin: 0; font-size: 12px;">Analytic continuation needed<br>Functional equation relates ζ(s) to ζ(1-s)</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">The Critical Strip:</h6>
                        <p style="margin: 0; font-size: 12px;">0 < σ < 1<br>Where non-trivial zeros live</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🎯 The Critical Zeros and Prime Connection</h5>
            
            <div style="background: rgba(255, 107, 107, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #ff6b6b; margin-top: 0;">Euler's Product Formula (The Bridge to Primes)</h6>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 14px; margin: 10px 0;">
                    ζ(s) = Π<sub>p prime</sub> 1/(1 - 1/p<sup>s</sup>)
                </div>
                <p style="margin: 10px 0; font-size: 13px;"><strong>This is why ζ(s) encodes all information about primes!</strong> Every prime p contributes a factor to the infinite product.</p>
            </div>
            
            <div style="background: rgba(254, 202, 87, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #feca57; margin-top: 0;">The Explicit Formula (How Zeros Control Primes)</h6>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 14px; margin: 10px 0;">
                    π(x) = Li(x) - Σ<sub>ρ</sub> Li(x<sup>ρ</sup>) + O(x<sup>1/2</sup>)
                </div>
                <p style="margin: 10px 0; font-size: 13px;">Where ρ = 1/2 + it are the <strong>critical zeros</strong>. Each zero ρ contributes an oscillatory term Li(x<sup>ρ</sup>) to the prime counting function!</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div>
                        <h7 style="color: #feca57; font-weight: bold;">If RH is True (all zeros on σ = 1/2):</h7>
                        <ul style="margin: 5px 0; padding-left: 15px; font-size: 12px;">
                            <li>|π(x) - Li(x)| ≪ √x ln(x)</li>
                            <li>Prime gaps ≪ √p ln(p)</li>
                            <li>Oscillations are "balanced"</li>
                        </ul>
                    </div>
                    <div>
                        <h7 style="color: #ff6b6b; font-weight: bold;">If RH is False (zeros off the line):</h7>
                        <ul style="margin: 5px 0; padding-left: 15px; font-size: 12px;">
                            <li>Larger deviations possible</li>
                            <li>Prime distribution less regular</li>
                            <li>Cryptographic implications</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🔗 How Our Möbius Verification Connects to Zeros</h5>
            
            <div style="background: rgba(78, 205, 196, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #4ecdc4; margin-top: 0;">The Deep Connection</h6>
                <p style="margin: 10px 0; font-size: 13px;">Our exponential sums S(N,α) = Σ μ(n)e<sup>2πinα</sup> are related to the zeta zeros through:</p>
                
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 13px; margin: 15px 0; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px;">
                    Σ<sub>n≤x</sub> μ(n) = Σ<sub>ρ</sub> x<sup>ρ</sup>/ρ ζ'(ρ)/ζ(ρ) + lower order terms
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h7 style="color: #4ecdc4; font-weight: bold;">When |S(N,α)| is small:</h7>
                        <p style="margin: 5px 0; font-size: 12px;">• Zeros are behaving "as expected"<br>• Cancellation is working properly<br>• RH predictions hold</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h7 style="color: #ff6b6b; font-weight: bold;">When |S(N,α)| is large:</h7>
                        <p style="margin: 5px 0; font-size: 12px;">• Possible resonance effects<br>• Zero distribution anomalies<br>• Interesting mathematics!</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🌐 The Complete Picture: All s Values</h5>
            
            <div style="background: linear-gradient(135deg, rgba(150, 206, 180, 0.1), rgba(68, 160, 141, 0.1)); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">📍 Trivial Zeros (s = -2, -4, -6, ...)</h6>
                        <p style="margin: 0; font-size: 12px;">At negative even integers. These come from the functional equation and are well understood. They don't affect prime distribution significantly.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">🎯 Critical Zeros (σ = 1/2 + it)</h6>
                        <p style="margin: 0; font-size: 12px;"><strong>The stars of the show!</strong> These control prime distribution. RH says they ALL lie on the critical line σ = 1/2.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">🚫 The Critical Strip (0 < σ < 1)</h6>
                        <p style="margin: 0; font-size: 12px;">If any non-trivial zeros exist off the line σ = 1/2 but in this strip, RH fails and prime behavior becomes less predictable.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;">🔄 Functional Equation</h6>
                        <p style="margin: 0; font-size: 12px;">ζ(s) = 2<sup>s</sup>π<sup>s-1</sup>sin(πs/2)Γ(1-s)ζ(1-s)<br>Relates values at s and 1-s</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🔢 Known Zero Statistics</h5>
            
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 12px;">
                <tr style="background: rgba(255,255,255,0.1);">
                    <th style="padding: 8px; border: 1px solid #666;">Height Range</th>
                    <th style="padding: 8px; border: 1px solid #666;">Zeros Computed</th>
                    <th style="padding: 8px; border: 1px solid #666;">All on σ = 1/2?</th>
                    <th style="padding: 8px; border: 1px solid #666;">Computational Effort</th>
                </tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 100</td><td style="padding: 6px; border: 1px solid #666;">29</td><td style="padding: 6px; border: 1px solid #666;">✅ Yes</td><td style="padding: 6px; border: 1px solid #666;">By hand (Riemann era)</td></tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 10,000</td><td style="padding: 6px; border: 1px solid #666;">~3,000</td><td style="padding: 6px; border: 1px solid #666;">✅ Yes</td><td style="padding: 6px; border: 1px solid #666;">Early computers</td></tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 10¹³</td><td style="padding: 6px; border: 1px solid #666;">~10¹³</td><td style="padding: 6px; border: 1px solid #666;">✅ Yes</td><td style="padding: 6px; border: 1px solid #666;">Modern supercomputers</td></tr>
            </table>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🎼 The Beautiful Harmony</h5>
            
            <div style="background: rgba(69, 183, 209, 0.1); border: 1px solid rgba(69, 183, 209, 0.3); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <p style="margin: 0; font-style: italic; font-size: 14px;"><strong>The zeros of ζ(s) are like the "harmonics" of the prime number "symphony."</strong></p>
                
                <ul style="margin: 10px 0; padding-left: 20px; font-size: 13px;">
                    <li><strong>Each zero ρ = 1/2 + it</strong> contributes an oscillation Li(x<sup>ρ</sup>) = Li(x<sup>1/2+it</sup>) to the prime counting function</li>
                    <li><strong>The imaginary parts t</strong> determine the "frequencies" of oscillation in prime distribution</li>
                    <li><strong>If all zeros are on σ = 1/2,</strong> these oscillations are perfectly balanced and cancel optimally</li>
                    <li><strong>Our Möbius verification</strong> checks that this cancellation is working as RH predicts</li>
                </ul>
                
                <div style="text-align: center; margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                    <strong>Every small ratio |S(N,α)|/√N we compute is evidence that the zeros are singing in perfect harmony! 🎵</strong>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🔬 What Our Verification Specifically Tests</h5>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 12px;">
                    <h6 style="color: #ff6b6b; margin: 0 0 8px 0;">Direct Zero Impact</h6>
                    <p style="margin: 0; font-size: 12px;">Our sums are directly influenced by zeros with imaginary parts t ≈ α·N/(2π). We're probing the zero distribution!</p>
                </div>
                
                <div style="background: rgba(254, 202, 87, 0.1); border-left: 4px solid #feca57; padding: 12px;">
                    <h6 style="color: #feca57; margin: 0 0 8px 0;">Cancellation Quality</h6>
                    <p style="margin: 0; font-size: 12px;">Small ratios mean the zeros are creating the precise cancellations needed for RH error bounds.</p>
                </div>
                
                <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 12px;">
                    <h6 style="color: #4ecdc4; margin: 0 0 8px 0;">Statistical Behavior</h6>
                    <p style="margin: 0; font-size: 12px;">The distribution of our results reflects the statistical properties of zeros predicted by random matrix theory.</p>
                </div>
            </div>
            
            <div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.15), rgba(68, 160, 141, 0.15)); border-radius: 10px; padding: 20px; margin: 20px 0; border: 2px solid rgba(78, 205, 196, 0.3);">
                <h6 style="color: #4ecdc4; margin: 0 0 15px 0; text-align: center; font-size: 16px;">🌟 The Grand Unification</h6>
                <p style="margin: 0; text-align: center; font-size: 14px; font-style: italic;">Our browser-based Möbius verification connects:</p>
                <div style="text-align: center; margin: 15px 0; line-height: 1.8;">
                    <strong>Riemann Zeta Zeros</strong> ↔ <strong>Prime Distribution</strong> ↔ <strong>Möbius Cancellation</strong> ↔ <strong>Cryptographic Security</strong>
                </div>
                <p style="margin: 15px 0 0 0; text-align: center; font-size: 13px;">Every test you run explores this magnificent mathematical symphony! 🎼</p>
            </div>
        </div>
            
            <p><strong>What we're testing:</strong> Under the Riemann Hypothesis, these Möbius exponential sums should satisfy |S(N,α)| = O(√N) uniformly in α. If we find ratios significantly larger than √N, it could indicate interesting mathematical phenomena or even contradict RH predictions.</p>
            
            <h4>The Möbius Function μ(n)</h4>
            <p>The Möbius function is defined as:</p>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li><strong>μ(n) = 1</strong> if n is a square-free positive integer with an even number of prime factors</li>
                <li><strong>μ(n) = -1</strong> if n is a square-free positive integer with an odd number of prime factors</li>
                <li><strong>μ(n) = 0</strong> if n has a squared prime factor</li>
            </ul>
            <p>Examples: μ(1)=1, μ(2)=-1, μ(3)=-1, μ(4)=0, μ(6)=1, μ(12)=0</p>
        </div>
        
        <div class="theory-box">
            <h4>Historical Context & Significance</h4>
            <p><strong>Prime Number Connection:</strong> The hypothesis directly relates to how accurately we can predict the distribution of prime numbers. If true, it provides the best possible bounds for counting primes.</p>
            
            <p><strong>Cryptographic Implications:</strong> Many modern encryption systems rely on the difficulty of factoring large numbers. RH predictions help us understand the security foundations of these systems.</p>
            
            <p><strong>Computational Verification:</strong> The hypothesis has been verified for the first 10<sup>13</sup> zeros, but a general proof remains one of mathematics' greatest challenges.</p>
        </div>
        
        <div class="theory-box">
            <h4>🔢 What This Tells Us About Prime Numbers</h4>
            
            <div style="background: rgba(78, 205, 196, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h5 style="color: #4ecdc4; margin-top: 0;">The Gauss-Legendre Connection</h5>
                <p><strong>π(x)</strong> = actual count of primes ≤ x &nbsp;|&nbsp; <strong>Li(x)</strong> = logarithmic integral ≈ x/ln(x)</p>
                <p><strong>Historic Insight:</strong> In 1792, 15-year-old Gauss predicted π(x) ≈ Li(x). Our RH verification directly validates this prediction!</p>
                
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 12px;">
                    <tr style="background: rgba(255,255,255,0.1);">
                        <th style="padding: 8px; border: 1px solid #666;">x</th>
                        <th style="padding: 8px; border: 1px solid #666;">π(x) actual</th>
                        <th style="padding: 8px; border: 1px solid #666;">Li(x) Gauss</th>
                        <th style="padding: 8px; border: 1px solid #666;">Error</th>
                        <th style="padding: 8px; border: 1px solid #666;">Error %</th>
                    </tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10³</td><td style="padding: 6px; border: 1px solid #666;">168</td><td style="padding: 6px; border: 1px solid #666;">178</td><td style="padding: 6px; border: 1px solid #666;">+10</td><td style="padding: 6px; border: 1px solid #666;">5.9%</td></tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10⁶</td><td style="padding: 6px; border: 1px solid #666;">78,498</td><td style="padding: 6px; border: 1px solid #666;">78,628</td><td style="padding: 6px; border: 1px solid #666;">+130</td><td style="padding: 6px; border: 1px solid #666;">0.17%</td></tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10⁹</td><td style="padding: 6px; border: 1px solid #666;">50,847,534</td><td style="padding: 6px; border: 1px solid #666;">50,849,235</td><td style="padding: 6px; border: 1px solid #666;">+1,701</td><td style="padding: 6px; border: 1px solid #666;">0.003%</td></tr>
                </table>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">How Our Verification Validates Prime Behavior</h5>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 10px;">
                    <h6 style="color: #ff6b6b; margin: 0 0 8px 0;">🌟 When Ratio < 1.0</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Prime gaps stay close to ln(x)</li>
                        <li>No large "prime deserts"</li>
                        <li>Gauss's formula is highly accurate</li>
                        <li>Cryptographic security is strong</li>
                    </ul>
                </div>
                
                <div style="background: rgba(254, 202, 87, 0.1); border-left: 4px solid #feca57; padding: 10px;">
                    <h6 style="color: #feca57; margin: 0 0 8px 0;">⭐ Major Arc Dominance</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Primes in arithmetic progressions behave regularly</li>
                        <li>Dirichlet's theorem is validated</li>
                        <li>Twin prime patterns follow predictions</li>
                        <li>Hardy-Littlewood conjectures gain support</li>
                    </ul>
                </div>
                
                <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 10px;">
                    <h6 style="color: #4ecdc4; margin: 0 0 8px 0;">📊 Low Variance Results</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Primes avoid excessive clustering</li>
                        <li>Cramér's conjecture gains support</li>
                        <li>Random matrix connections validated</li>
                        <li>Prime Number Theorem error bounds tight</li>
                    </ul>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">Real-World Applications</h5>
            <div style="background: rgba(150, 206, 180, 0.1); border-radius: 8px; padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;">🔐 Cryptography</h6>
                        <p style="margin: 0; font-size: 12px;">RSA security, prime generation, key sizing, factoring difficulty bounds</p>
                    </div>
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;">🧮 Algorithms</h6>
                        <p style="margin: 0; font-size: 12px;">Primality testing, hash functions, pseudorandom generators, sieve optimization</p>
                    </div>
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;">📚 Mathematics</h6>
                        <p style="margin: 0; font-size: 12px;">L-functions, automorphic forms, analytic number theory, additive combinatorics</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">What Our Möbius Sums Reveal</h5>
            <p>The exponential sums S(N,α) = Σ μ(n)e^(2πinα) are intimately connected to prime distribution through:</p>
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 15px; font-family: 'Courier New', monospace; margin: 10px 0;">
                <div style="text-align: center; margin-bottom: 10px;">π(x) = Li(x) - Σ<sub>ρ</sub> Li(x<sup>ρ</sup>) + O(x<sup>θ</sup>)</div>
                <div style="font-size: 11px; text-align: center; color: #a0a0a0;">Riemann's exact prime counting formula</div>
            </div>
            <ul style="font-size: 13px; margin: 10px 0;">
                <li><strong>Small ratios |S(N,α)|/√N:</strong> Error terms π(x) - Li(x) are controlled ≪ √x ln(x)</li>
                <li><strong>Major arc peaks:</strong> Primes in arithmetic progressions follow Dirichlet predictions</li>
                <li><strong>Smooth convergence:</strong> No chaotic behavior - primes are "well-distributed"</li>
                <li><strong>Low variance:</strong> Prime gaps stay near logarithmic average</li>
            </ul>
            
            <div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1)); border-radius: 8px; padding: 15px; margin: 15px 0; border: 1px solid rgba(78, 205, 196, 0.3);">
                <h6 style="color: #4ecdc4; margin: 0 0 10px 0;">🎯 The Beautiful Connection</h6>
                <p style="margin: 0; font-style: italic;">Every successful RH verification means: <strong>"Primes are distributed so regularly that a teenager's 1792 intuition predicts their count to within √N accuracy!"</strong></p>
                <p style="margin: 10px 0 0 0; font-size: 12px;">When you see smooth, low-ratio visualizations, you're witnessing computational proof that the universe's prime distribution follows deep, predictable patterns that Gauss intuited over 230 years ago.</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>🎯 Test Configuration</h3>
                
                <label for="maxN">Maximum N:</label>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="setPreset(100000)">100K</button>
                    <button class="preset-btn" onclick="setPreset(500000)">500K</button>
                    <button class="preset-btn" onclick="setPreset(1000000)">1M</button>
                    <button class="preset-btn" onclick="setPreset(5000000)">5M</button>
                    <button class="preset-btn" onclick="setPreset(10000000)">10M</button>
                    <button class="preset-btn" onclick="setPreset(25000000)">25M</button>
                    <button class="preset-btn" onclick="setPreset(50000000)">50M</button>
                    <button class="preset-btn" onclick="setPreset(100000000)">100M</button>
                </div>
                <input type="number" id="customN" value="1000000" min="1" max="100000000" placeholder="Enter custom N value">
                
                <div id="performanceIndicator" class="performance-indicator perf-excellent">
                    ⚡ Excellent performance expected (~1-2 seconds)
                </div>
                
                <label for="testMode">Test Mode:</label>
                <select id="testMode">
                    <option value="stochastic">Stochastic α sampling</option>
                    <option value="major-arcs" selected>Major arcs analysis</option>
                    <option value="uniform">Uniform grid</option>
                    <option value="comprehensive">Comprehensive (all methods)</option>
                    <option value="adaptive">Adaptive precision</option>
                </select>
            </div>
            
            <div class="control-group">
                <h3>⚙️ Sampling Parameters</h3>
                
                <div class="two-column">
                    <div>
                        <label for="numSamples">Number of α samples:</label>
                        <input type="number" id="numSamples" value="100" min="10" max="2000">
                        <small>More samples = better coverage</small>
                    </div>
                    
                    <div>
                        <label for="maxDenom">Max denominator (major arcs):</label>
                        <input type="number" id="maxDenom" value="12" min="2" max="50">
                        <small>Higher values test more rational α = a/q</small>
                    </div>
                </div>
                
                <div class="two-column">
                    <div>
                        <label for="gridSize">Grid size (uniform mode):</label>
                        <input type="number" id="gridSize" value="64" min="8" max="256">
                        <small>Grid resolution for uniform sampling</small>
                    </div>
                    
                    <div>
                        <label for="precisionLevel">Precision level:</label>
                        <select id="precisionLevel">
                            <option value="standard">Standard</option>
                            <option value="high" selected>High</option>
                            <option value="ultra">Ultra (slow)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>📊 Visualization & Analysis</h3>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showDetails" checked>
                    <label for="showDetails">Show detailed analysis</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="generateHeatmap" checked>
                    <label for="generateHeatmap">Generate complexity heatmap</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showStatistics" checked>
                    <label for="showStatistics">Statistical analysis</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="realTimeUpdates">
                    <label for="realTimeUpdates">Real-time progress updates</label>
                </div>
                
                <div class="advanced-options">
                    <h4 style="margin-top: 0; color: #96ceb4;">Advanced Options</h4>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enablePhaseAnalysis">
                        <label for="enablePhaseAnalysis">Phase analysis</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableDistributionAnalysis">
                        <label for="enableDistributionAnalysis">Distribution analysis</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableFrequencyAnalysis">
                        <label for="enableFrequencyAnalysis">Frequency domain analysis</label>
                    </div>
                </div>
                
                <button id="startTest">🚀 Launch Enhanced Cosmic Test</button>
            </div>
        </div>
        
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="statusText" class="status computing">Initializing enhanced computation...</div>
        </div>
        
        <div class="results" id="results" style="display: none;">
            <h3>📊 Enhanced Cosmic Verification Results</h3>
            
            <div class="metrics-grid">
                <div class="metric">
                    <span class="metric-label">Maximum N tested:</span>
                    <span class="metric-value" id="resultN">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">√N (theoretical bound):</span>
                    <span class="metric-value" id="resultSqrtN">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Maximum |S(N,α)| found:</span>
                    <span class="metric-value" id="resultMaxSum">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Ratio |S(N,α)|/√N:</span>
                    <span class="metric-value" id="resultRatio">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Best α value:</span>
                    <span class="metric-value" id="resultBestAlpha">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Computation time:</span>
                    <span class="metric-value" id="computeTime">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Operations per second:</span>
                    <span class="metric-value" id="opsPerSec">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Memory efficiency:</span>
                    <span class="metric-value" id="memoryEff">-</span>
                </div>
            </div>

            <div class="cosmic-status" id="cosmicStatus" style="display: none;">
                🌟 Status will appear here
            </div>
            
            <div id="statisticalSummary" style="display: none;">
                <h4 style="color: #4ecdc4; margin-bottom: 15px;">Statistical Summary</h4>
                <div class="statistics-grid" id="statsGrid">
                    <!-- Statistics will be populated here -->
                </div>
            </div>
            
            <div id="detailedResults" style="display: none;" class="detailed-results">
                <div class="results-tabs">
                    <button class="tab-button active" onclick="switchTab('topResults')">Top Results</button>
                    <button class="tab-button" onclick="switchTab('insights')">Mathematical Insights</button>
                    <button class="tab-button" onclick="switchTab('distribution')">Distribution Analysis</button>
                    <button class="tab-button" onclick="switchTab('phase')">Phase Analysis</button>
                    <button class="tab-button" onclick="switchTab('export')">Export Data</button>
                </div>
                
                <div id="topResults" class="tab-content active">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Top Exponential Sum Values</h4>
                    <table class="top-results-table" id="topResultsTable">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>α value</th>
                                <th>|S(N,α)|</th>
                                <th>Ratio</th>
                                <th>Type</th>
                            </tr>
                        </thead>
                        <tbody id="topResultsBody">
                        </tbody>
                    </table>
                </div>
                
                <div id="insights" class="tab-content">
                    <div class="insights">
                        <h5 style="color: #4ecdc4; margin-bottom: 10px;">Mathematical Insights</h5>
                        <div id="insightsContent">
                            <p>Complete a test to see detailed analysis and insights.</p>
                        </div>
                    </div>
                </div>
                
                <div id="distribution" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Distribution Analysis</h4>
                    <div id="distributionAnalysis">
                        <p>Distribution analysis will appear here after computation.</p>
                    </div>
                </div>
                
                <div id="phase" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Phase Analysis</h4>
                    <div id="phaseAnalysis">
                        <p>Phase analysis will appear here after computation.</p>
                    </div>
                </div>
                
                <div id="export" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Export Data</h4>
                    <div class="export-buttons">
                        <button class="export-btn" onclick="exportResults('csv')">📄 Export CSV</button>
                        <button class="export-btn" onclick="exportResults('json')">📋 Export JSON</button>
                        <button class="export-btn" onclick="exportResults('txt')">📝 Export Report</button>
                        <button class="export-btn" onclick="exportVisualization()">🖼️ Export Charts</button>
                    </div>
                    <p style="margin-top: 15px; color: #a0a0a0;">Export your results in various formats for further analysis or sharing.</p>
                </div>
            </div>
        </div>
        
        <div class="visualization-grid" id="visualizationGrid" style="display: none;">
            <div class="visualization-item">
                <h4>Exponential Sum Distribution</h4>
                <canvas id="sumChart" width="400" height="300"></canvas>
                <div class="chart-info" id="sumChartInfo">
                    <div class="chart-info-title">Click on points to see details</div>
                    <div id="sumChartDetails">Hover over data points or click for exact values</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Complexity Heatmap</h4>
                <div class="heatmap-container">
                    <canvas id="heatmapChart" width="400" height="300"></canvas>
                    <div class="chart-info" id="heatmapInfo">
                        <div class="chart-info-title">Heatmap Values</div>
                        <div id="heatmapDetails">Click on cells to see sum values</div>
                    </div>
                    <div class="heatmap-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ecdc4;"></div>
                            <span>Low</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #feca57;"></div>
                            <span>Medium</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b6b;"></div>
                            <span>High</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Phase Distribution</h4>
                <canvas id="phaseChart" width="400" height="300"></canvas>
                <div class="chart-info" id="phaseChartInfo">
                    <div class="chart-info-title">Phase Analysis</div>
                    <div id="phaseChartDetails">Click on points to see phase and magnitude</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Convergence Analysis</h4>
                <canvas id="convergenceChart" width="400" height="300"></canvas>
                <div class="chart-info" id="convergenceChartInfo">
                    <div class="chart-info-title">Convergence Data</div>
                    <div id="convergenceChartDetails">Click on the line to see iteration details</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Ratio vs α Scatter Plot</h4>
                <canvas id="scatterChart" width="400" height="300"></canvas>
                <div class="chart-info" id="scatterChartInfo">
                    <div class="chart-info-title">Scatter Plot Data</div>
                    <div id="scatterChartDetails">Click on points to see α and ratio values</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Statistical Distribution</h4>
                <canvas id="histogramChart" width="400" height="300"></canvas>
                <div class="chart-info" id="histogramInfo">
                    <div class="chart-info-title">Histogram Data</div>
                    <div id="histogramDetails">Click on bars to see frequency counts</div>
                </div>
            </div>
        </div>
        
        <!-- Tooltip for interactive charts -->
        <div class="chart-tooltip" id="chartTooltip"></div>
    </div>

    <script>
        class EnhancedRiemannHypothesisTester {
            constructor() {
                this.mobius = [];
                this.maxN = 0;
                this.isComputing = false;
                this.results = [];
                this.phaseData = [];
                this.convergenceData = [];
                this.currentTest = null;
            }

            // Optimized Möbius function computation using sieve method
            computeMobius(n) {
                console.log('Computing Möbius function up to ' + n + '...');
                const startTime = performance.now();
                
                this.mobius = new Int8Array(n + 1);
                const smallestPrimeFactor = new Array(n + 1).fill(0);
                
                // Initialize
                this.mobius[1] = 1;
                
                // Sieve to find smallest prime factors
                for (let i = 2; i <= n; i++) {
                    if (smallestPrimeFactor[i] === 0) {
                        // i is prime
                        smallestPrimeFactor[i] = i;
                        for (let j = i * i; j <= n; j += i) {
                            if (smallestPrimeFactor[j] === 0) {
                                smallestPrimeFactor[j] = i;
                            }
                        }
                    }
                }
                
                // Compute Möbius function using multiplicative property
                for (let i = 2; i <= n; i++) {
                    const p = smallestPrimeFactor[i];
                    const quotient = Math.floor(i / p);
                    
                    if (quotient % p === 0) {
                        // i is divisible by p², so μ(i) = 0
                        this.mobius[i] = 0;
                    } else {
                        // μ(i) = -μ(i/p) since p is the smallest prime factor
                        this.mobius[i] = -this.mobius[quotient];
                    }
                }
                
                const endTime = performance.now();
                console.log('Möbius computation completed in ' + (endTime - startTime).toFixed(2) + 'ms');
                this.maxN = n;
            }

            // Enhanced exponential sum computation with phase tracking
            computeExponentialSum(N, alpha, trackPhase = false) {
                let realSum = 0;
                let imagSum = 0;
                let phases = [];
                
                for (let n = 1; n <= N; n++) {
                    if (this.mobius[n] !== 0) {
                        const angle = 2 * Math.PI * n * alpha;
                        const cosVal = Math.cos(angle);
                        const sinVal = Math.sin(angle);
                        
                        realSum += this.mobius[n] * cosVal;
                        imagSum += this.mobius[n] * sinVal;
                        
                        if (trackPhase && n % Math.max(1, Math.floor(N / 50)) === 0) {
                            phases.push({
                                n: n,
                                phase: Math.atan2(imagSum, realSum),
                                magnitude: Math.sqrt(realSum * realSum + imagSum * imagSum),
                                alpha: alpha
                            });
                        }
                    }
                }
                
                const magnitude = Math.sqrt(realSum * realSum + imagSum * imagSum);
                const phase = Math.atan2(imagSum, realSum);
                
                return {
                    magnitude: magnitude,
                    phase: phase,
                    real: realSum,
                    imaginary: imagSum,
                    phases: phases
                };
            }

            // Generate enhanced α values based on mode and precision
            generateAlphaValues(mode, numSamples, maxDenom, gridSize, precision) {
                const alphas = [];
                
                switch (mode) {
                    case 'stochastic':
                        for (let i = 0; i < numSamples; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'major-arcs':
                        // Test rational numbers with small denominators
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                }
                            }
                        }
                        // Add some random values too
                        const randomCount = Math.min(Math.floor(numSamples / 2), 100);
                        for (let i = 0; i < randomCount; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'uniform':
                        for (let i = 0; i < gridSize; i++) {
                            for (let j = 0; j < gridSize; j++) {
                                alphas.push((i + 0.5) / gridSize);
                                if (alphas.length >= numSamples) break;
                            }
                            if (alphas.length >= numSamples) break;
                        }
                        break;
                        
                    case 'adaptive':
                        // Start with major arcs, then adaptively refine
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                    // Add nearby points for adaptive refinement
                                    if (precision === 'high' || precision === 'ultra') {
                                        const delta = precision === 'ultra' ? 0.001 : 0.01;
                                        alphas.push((p / q) + delta);
                                        alphas.push((p / q) - delta);
                                    }
                                }
                            }
                        }
                        // Add adaptive grid points
                        for (let i = 0; i < numSamples; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'comprehensive':
                        // Combine all methods for thorough testing
                        // Major arcs
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                }
                            }
                        }
                        // Uniform grid
                        for (let i = 0; i < gridSize; i++) {
                            alphas.push(i / gridSize);
                        }
                        // Random sampling
                        for (let i = 0; i < Math.floor(numSamples / 2); i++) {
                            alphas.push(Math.random());
                        }
                        break;
                }
                
                return [...new Set(alphas.map(a => Math.abs(a % 1)))]; // Remove duplicates and normalize
            }

            gcd(a, b) {
                while (b !== 0) {
                    [a, b] = [b, a % b];
                }
                return a;
            }

            formatAlpha(alpha) {
                // Try to express as a simple fraction
                const tolerance = 1e-10;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            return num + '/' + denom;
                        }
                    }
                }
                return alpha.toFixed(8);
            }

            determineAlphaType(alpha) {
                const tolerance = 1e-10;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            if (denom <= 12) return 'Major Arc';
                            return 'Rational';
                        }
                    }
                }
                return 'Irrational';
            }

            async runEnhancedVerification(maxN, testMode, numSamples, maxDenom, gridSize, precision, options) {
                return new Promise((resolve) => {
                    const startTime = performance.now();
                    
                    // Update UI
                    document.getElementById('progressContainer').style.display = 'block';
                    document.getElementById('results').style.display = 'none';
                    document.getElementById('visualizationGrid').style.display = 'none';
                    
                    const updateProgress = (message, progress) => {
                        document.getElementById('statusText').textContent = message;
                        document.getElementById('progressFill').style.width = progress + '%';
                    };
                    
                    // Initialize variables at the top level
                    let maxSum = 0;
                    let bestAlpha = 0;
                    const results = [];
                    const convergencePoints = [];
                    let phaseData = []; // Declare at function scope
                    
                    // Store phaseData in instance for later access
                    this.phaseData = [];
                    
                    setTimeout(() => {
                        updateProgress('Computing enhanced Möbius function...', 5);
                        
                        setTimeout(() => {
                            // Step 1: Compute Möbius function
                            this.computeMobius(maxN);
                            updateProgress('Generating α test values with ' + precision + ' precision...', 15);
                            
                            setTimeout(() => {
                                // Step 2: Generate α values
                                const alphas = this.generateAlphaValues(testMode, numSamples, maxDenom, gridSize, precision);
                                updateProgress('Testing ' + alphas.length + ' α values with enhanced analysis...', 25);
                                
                                setTimeout(() => {
                                    // Step 3: Test exponential sums with enhanced tracking
                                    const sqrtN = Math.sqrt(maxN);
                                    
                                    alphas.forEach((alpha, i) => {
                                        const trackPhase = options.enablePhaseAnalysis && i < 10;
                                        const sumResult = this.computeExponentialSum(maxN, alpha, trackPhase);
                                        
                                        results.push({
                                            alpha: alpha,
                                            sum: sumResult.magnitude,
                                            phase: sumResult.phase,
                                            real: sumResult.real,
                                            imaginary: sumResult.imaginary,
                                            type: this.determineAlphaType(alpha)
                                        });
                                        
                                        if (trackPhase && sumResult.phases && sumResult.phases.length > 0) {
                                            phaseData = phaseData.concat(sumResult.phases);
                                            this.phaseData = this.phaseData.concat(sumResult.phases);
                                        }
                                        
                                        if (sumResult.magnitude > maxSum) {
                                            maxSum = sumResult.magnitude;
                                            bestAlpha = alpha;
                                        }
                                        
                                        // Track convergence
                                        if (i % Math.max(1, Math.floor(alphas.length / 20)) === 0) {
                                            convergencePoints.push({
                                                iteration: i,
                                                maxSum: maxSum,
                                                currentSum: sumResult.magnitude
                                            });
                                        }
                                        
                                        if (options.realTimeUpdates && i % Math.max(1, Math.floor(alphas.length / 20)) === 0) {
                                            const progress = 25 + 65 * (i / alphas.length);
                                            updateProgress('Testing α values... ' + (i + 1) + '/' + alphas.length + ' (max: ' + maxSum.toFixed(3) + ')', progress);
                                        }
                                    });
                                    
                                    const endTime = performance.now();
                                    const computeTime = endTime - startTime;
                                    const ratio = maxSum / sqrtN;
                                    
                                    updateProgress('Generating advanced visualizations...', 95);
                                    
                                    setTimeout(() => {
                                        updateProgress('Enhanced computation complete!', 100);
                                        
                                        resolve({
                                            maxN,
                                            sqrtN,
                                            maxSum,
                                            ratio,
                                            bestAlpha,
                                            computeTime,
                                            results: results.sort((a, b) => b.sum - a.sum),
                                            phaseData: phaseData,
                                            convergenceData: convergencePoints,
                                            statistics: this.calculateStatistics(results),
                                            options
                                        });
                                    }, 200);
                                }, 100);
                            }, 100);
                        }, 100);
                    }, 100);
                });
            }

            calculateStatistics(results) {
                const sums = results.map(r => r.sum);
                const phases = results.map(r => r.phase);
                
                return {
                    mean: sums.reduce((a, b) => a + b, 0) / sums.length,
                    median: this.median(sums),
                    stdDev: this.standardDeviation(sums),
                    variance: this.variance(sums),
                    skewness: this.skewness(sums),
                    kurtosis: this.kurtosis(sums),
                    min: Math.min(...sums),
                    max: Math.max(...sums),
                    q1: this.percentile(sums, 25),
                    q3: this.percentile(sums, 75),
                    majorArcCount: results.filter(r => r.type === 'Major Arc').length,
                    rationalCount: results.filter(r => r.type === 'Rational').length,
                    irrationalCount: results.filter(r => r.type === 'Irrational').length
                };
            }

            median(arr) {
                const sorted = [...arr].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
            }

            standardDeviation(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
                return Math.sqrt(variance);
            }

            variance(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                return arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
            }

            skewness(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = this.standardDeviation(arr);
                const n = arr.length;
                return arr.reduce((sum, val) => sum + Math.pow((val - mean) / std, 3), 0) / n;
            }

            kurtosis(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = this.standardDeviation(arr);
                const n = arr.length;
                return arr.reduce((sum, val) => sum + Math.pow((val - mean) / std, 4), 0) / n - 3;
            }

            percentile(arr, p) {
                const sorted = [...arr].sort((a, b) => a - b);
                const index = (p / 100) * (sorted.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                return sorted[lower] + (sorted[upper] - sorted[lower]) * (index - lower);
            }

            displayEnhancedResults(results) {
                const {maxN, sqrtN, maxSum, ratio, bestAlpha, computeTime, results: topResults, statistics, options} = results;
                
                // Basic metrics
                document.getElementById('resultN').textContent = maxN.toLocaleString();
                document.getElementById('resultSqrtN').textContent = sqrtN.toFixed(2);
                document.getElementById('resultMaxSum').textContent = maxSum.toFixed(6);
                document.getElementById('resultRatio').textContent = ratio.toFixed(8);
                document.getElementById('resultBestAlpha').textContent = this.formatAlpha(bestAlpha);
                document.getElementById('computeTime').textContent = (computeTime/1000).toFixed(3) + 's';
                document.getElementById('opsPerSec').textContent = (maxN / (computeTime/1000)).toExponential(3);
                document.getElementById('memoryEff').textContent = (maxN / (1024 * 1024)).toFixed(2) + 'MB';
                
                // Enhanced RH status with cosmic themes
                let rhStatus, rhClass;
                if (ratio < 0.2) {
                    rhStatus = '🌌 COSMIC EXCELLENCE - Extraordinary RH Support (ratio < 0.2)';
                    rhClass = 'status-cosmic';
                } else if (ratio < 0.4) {
                    rhStatus = '🌟 LEGENDARY - Outstanding RH Support (ratio < 0.4)';
                    rhClass = 'status-legendary';
                } else if (ratio < 0.8) {
                    rhStatus = '✨ MYTHICAL - Excellent RH Support (ratio < 0.8)';
                    rhClass = 'status-mythical';
                } else if (ratio < 1.5) {
                    rhStatus = '⭐ EXCELLENT - Good RH Support (ratio < 1.5)';
                    rhClass = 'status-excellent';
                } else if (ratio < 3.0) {
                    rhStatus = '👍 GOOD - Acceptable RH Support (ratio < 3.0)';
                    rhClass = 'status-good';
                } else {
                    rhStatus = '⚠️ HIGH - Needs Investigation (ratio ≥ 3.0)';
                    rhClass = 'status-high';
                }
                
                const statusElement = document.getElementById('cosmicStatus');
                statusElement.textContent = rhStatus;
                statusElement.className = 'cosmic-status ' + rhClass;
                statusElement.style.display = 'block';
                
                // Statistical summary
                if (options.showStatistics && statistics) {
                    this.displayStatistics(statistics);
                    document.getElementById('statisticalSummary').style.display = 'block';
                }
                
                // Show detailed results if enabled
                if (options.showDetails) {
                    this.displayDetailedResults(topResults, maxN, sqrtN, ratio, statistics);
                    document.getElementById('detailedResults').style.display = 'block';
                } else {
                    document.getElementById('detailedResults').style.display = 'none';
                }
                
                document.getElementById('results').style.display = 'block';
                document.getElementById('progressContainer').style.display = 'none';
                
                // Store results for export
                this.currentTest = results;
                
                // Generate visualizations
                if (options.generateHeatmap || options.showDetails) {
                    this.generateEnhancedVisualizations(results);
                }
                
                // Debug: Log phase data availability
                console.log('Phase data available:', results.phaseData ? results.phaseData.length : 0, 'points');
                if (results.phaseData && results.phaseData.length > 0) {
                    console.log('First phase point:', results.phaseData[0]);
                }
            }

            displayStatistics(stats) {
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-value">${stats.mean.toFixed(4)}</div>
                        <div class="stat-label">Mean |S(N,α)|</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.median.toFixed(4)}</div>
                        <div class="stat-label">Median |S(N,α)|</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.stdDev.toFixed(4)}</div>
                        <div class="stat-label">Standard Deviation</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.skewness.toFixed(3)}</div>
                        <div class="stat-label">Skewness</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.majorArcCount}</div>
                        <div class="stat-label">Major Arc Results</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${(stats.majorArcCount / (stats.majorArcCount + stats.rationalCount + stats.irrationalCount) * 100).toFixed(1)}%</div>
                        <div class="stat-label">Major Arc Percentage</div>
                    </div>
                `;
            }

            displayDetailedResults(topResults, maxN, sqrtN, ratio, statistics) {
                // Top results table
                const tbody = document.getElementById('topResultsBody');
                tbody.innerHTML = '';
                
                topResults.slice(0, 15).forEach((result, i) => {
                    const resultRatio = result.sum / sqrtN;
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${i + 1}</td>
                        <td>${this.formatAlpha(result.alpha)}</td>
                        <td>${result.sum.toFixed(6)}</td>
                        <td>${resultRatio.toFixed(6)}</td>
                        <td>${result.type}</td>
                    `;
                    tbody.appendChild(row);
                });
                
                // Mathematical insights
                const insights = this.generateEnhancedInsights(topResults, maxN, sqrtN, ratio, statistics);
                document.getElementById('insightsContent').innerHTML = insights;
                
                // Distribution analysis
                if (statistics) {
                    document.getElementById('distributionAnalysis').innerHTML = this.generateDistributionAnalysis(statistics, topResults);
                }
                
                // Phase analysis
                if (results.phaseData && results.phaseData.length > 0) {
                    document.getElementById('phaseAnalysis').innerHTML = this.generatePhaseAnalysis(results.phaseData);
                }
            }

            generateEnhancedInsights(topResults, maxN, sqrtN, ratio, statistics) {
                let insights = '';
                
                // Major arc dominance analysis
                const majorArcResults = topResults.filter(r => r.type === 'Major Arc').slice(0, 10);
                if (majorArcResults.length > 0) {
                    insights += `<p><strong>Major Arc Dominance:</strong> ${majorArcResults.length} of the top 10 exponential sums occur at major arc α values, confirming classical analytic number theory predictions.</p>`;
                }
                
                // Statistical significance
                if (statistics) {
                    insights += `<p><strong>Statistical Profile:</strong> Mean ratio: ${(statistics.mean / sqrtN).toFixed(4)}, Standard deviation: ${(statistics.stdDev / sqrtN).toFixed(4)}, Skewness: ${statistics.skewness.toFixed(3)}. `;
                    
                    if (Math.abs(statistics.skewness) < 0.5) {
                        insights += 'Distribution is approximately symmetric.</p>';
                    } else if (statistics.skewness > 0.5) {
                        insights += 'Distribution shows positive skew (tail towards larger values).</p>';
                    } else {
                        insights += 'Distribution shows negative skew (tail towards smaller values).</p>';
                    }
                }
                
                // RH interpretation with enhanced analysis
                if (ratio < 0.5) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} provides exceptionally strong computational evidence supporting the Riemann Hypothesis for N = ${maxN.toLocaleString()}. This level of bound satisfaction is remarkable.</p>`;
                } else if (ratio < 1.0) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} is well within theoretical bounds, providing solid evidence supporting RH predictions.</p>`;
                } else if (ratio < 2.0) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} remains within reasonable bounds for RH, though elevated. This is still consistent with the O(√N) prediction.</p>`;
                } else {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} is significantly elevated. While potentially still consistent with RH (which allows some flexibility), this warrants deeper investigation.</p>`;
                }
                
                // Computational achievement
                insights += `<p><strong>Computational Achievement:</strong> Successfully verified RH predictions for ${maxN.toLocaleString()} integers using advanced browser-based algorithms, demonstrating modern JavaScript's capability for serious mathematical research.</p>`;
                
                // Research directions
                insights += `<p><strong>Future Research:</strong> Consider investigating the specific α values producing maximal sums, exploring larger N values, or applying these techniques to related L-functions and Dirichlet series.</p>`;
                
                return insights;
            }

            generateDistributionAnalysis(statistics, results) {
                let analysis = `
                    <div class="statistics-grid">
                        <div class="stat-card">
                            <div class="stat-value">${statistics.q1.toFixed(4)}</div>
                            <div class="stat-label">First Quartile (Q1)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${statistics.q3.toFixed(4)}</div>
                            <div class="stat-label">Third Quartile (Q3)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${(statistics.q3 - statistics.q1).toFixed(4)}</div>
                            <div class="stat-label">Interquartile Range</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${statistics.kurtosis.toFixed(3)}</div>
                            <div class="stat-label">Kurtosis</div>
                        </div>
                    </div>
                `;
                
                // Distribution shape analysis
                analysis += '<h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">Distribution Shape Analysis</h5>';
                if (statistics.kurtosis > 0) {
                    analysis += '<p>The distribution exhibits positive kurtosis (heavy tails), indicating more extreme values than a normal distribution would predict.</p>';
                } else {
                    analysis += '<p>The distribution exhibits negative kurtosis (light tails), indicating fewer extreme values than expected.</p>';
                }
                
                // Type distribution
                analysis += '<h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">α Value Type Distribution</h5>';
                analysis += `<p>Major Arcs: ${statistics.majorArcCount}, Rational: ${statistics.rationalCount}, Irrational: ${statistics.irrationalCount}</p>`;
                
                return analysis;
            }

            generatePhaseAnalysis(phaseData) {
                if (!phaseData || phaseData.length === 0) {
                    return '<p>Phase analysis data not available for this test.</p>';
                }
                
                let analysis = '<h5 style="color: #4ecdc4; margin-bottom: 10px;">Phase Behavior Analysis</h5>';
                
                // Calculate phase statistics
                const phases = phaseData.map(p => p.phase);
                const meanPhase = phases.reduce((a, b) => a + b, 0) / phases.length;
                const phaseRange = Math.max(...phases) - Math.min(...phases);
                
                analysis += `<p><strong>Mean Phase:</strong> ${meanPhase.toFixed(4)} radians (${(meanPhase * 180 / Math.PI).toFixed(2)}°)</p>`;
                analysis += `<p><strong>Phase Range:</strong> ${phaseRange.toFixed(4)} radians (${(phaseRange * 180 / Math.PI).toFixed(2)}°)</p>`;
                
                // Phase distribution
                const phaseDistribution = this.analyzePhaseDistribution(phases);
                analysis += `<p><strong>Phase Distribution:</strong> ${phaseDistribution}</p>`;
                
                return analysis;
            }

            analyzePhaseDistribution(phases) {
                const bins = 8;
                const binSize = (2 * Math.PI) / bins;
                const counts = new Array(bins).fill(0);
                
                phases.forEach(phase => {
                    const normalizedPhase = ((phase % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                    const bin = Math.min(Math.floor(normalizedPhase / binSize), bins - 1);
                    counts[bin]++;
                });
                
                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);
                
                if (maxCount - minCount < phases.length * 0.1) {
                    return 'Approximately uniform distribution across phase space';
                } else {
                    return 'Non-uniform phase distribution with clustering';
                }
            }

            generateEnhancedVisualizations(results) {
                const {results: topResults, convergenceData, phaseData, options} = results;
                
                // Main distribution chart
                this.drawDistributionChart(topResults, results.sqrtN);
                
                // Heatmap if enabled
                if (options.generateHeatmap) {
                    this.drawComplexityHeatmap(topResults);
                }
                
                // Phase chart if data available
                if (phaseData && phaseData.length > 0) {
                    this.drawPhaseChart(phaseData);
                }
                
                // Convergence analysis
                if (convergenceData && convergenceData.length > 0) {
                    this.drawConvergenceChart(convergenceData);
                }
                
                // Scatter plot
                this.drawScatterPlot(topResults, results.sqrtN);
                
                // Histogram
                this.drawHistogram(topResults);
                
                document.getElementById('visualizationGrid').style.display = 'grid';
            }

            drawDistributionChart(results, sqrtN) {
                const canvas = document.getElementById('sumChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxSum = Math.max(...results.map(r => r.sum));
                const displayResults = results.slice(0, 50);
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw √N reference line
                const sqrtNY = canvas.height - padding - (sqrtN / maxSum) * height;
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(padding, sqrtNY);
                ctx.lineTo(canvas.width - padding, sqrtNY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw data points with color coding
                displayResults.forEach((result, i) => {
                    const x = padding + (i / (displayResults.length - 1)) * width;
                    const y = canvas.height - padding - (result.sum / maxSum) * height;
                    
                    // Color by type
                    if (result.type === 'Major Arc') {
                        ctx.fillStyle = '#ff6b6b';
                    } else if (result.type === 'Rational') {
                        ctx.fillStyle = '#feca57';
                    } else {
                        ctx.fillStyle = '#4ecdc4';
                    }
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('Top α values (ranked)', canvas.width / 2 - 50, canvas.height - 10);
                ctx.fillText('√N = ' + sqrtN.toFixed(1), canvas.width - 80, sqrtNY - 5);
            }

            drawComplexityHeatmap(results) {
                const canvas = document.getElementById('heatmapChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const gridSize = 32;
                const cellWidth = canvas.width / gridSize;
                const cellHeight = canvas.height / gridSize;
                
                // Create complexity grid
                const complexityGrid = new Array(gridSize).fill(null).map(() => new Array(gridSize).fill(0));
                
                results.slice(0, gridSize * gridSize).forEach((result, i) => {
                    const x = i % gridSize;
                    const y = Math.floor(i / gridSize);
                    complexityGrid[y][x] = result.sum;
                });
                
                const maxComplexity = Math.max(...results.map(r => r.sum));
                
                // Draw heatmap
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const intensity = complexityGrid[y][x] / maxComplexity;
                        const hue = (1 - intensity) * 180; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            drawPhaseChart(phaseData) {
                const canvas = document.getElementById('phaseChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 30;
                
                // Draw unit circle
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw axes
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX - radius, centerY);
                ctx.lineTo(centerX + radius, centerY);
                ctx.moveTo(centerX, centerY - radius);
                ctx.lineTo(centerX, centerY + radius);
                ctx.stroke();
                
                // If no phase data, show message and simulate some points
                if (!phaseData || phaseData.length === 0) {
                    ctx.fillStyle = '#a0a0a0';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Enable Phase Analysis to see data', centerX, centerY + 60);
                    
                    // Draw some example phase points in a circle pattern
                    ctx.fillStyle = '#666';
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * 2 * Math.PI;
                        const x = centerX + radius * 0.7 * Math.cos(angle);
                        const y = centerY + radius * 0.7 * Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    return;
                }
                
                // Plot actual phase points with color coding by magnitude
                const maxMagnitude = Math.max(...phaseData.map(p => p.magnitude));
                
                phaseData.forEach(point => {
                    const x = centerX + radius * 0.8 * Math.cos(point.phase);
                    const y = centerY + radius * 0.8 * Math.sin(point.phase);
                    
                    // Color based on magnitude
                    const intensity = point.magnitude / maxMagnitude;
                    const hue = intensity * 60; // Red to yellow
                    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Reset text alignment
                ctx.textAlign = 'left';
            }

            drawConvergenceChart(convergenceData) {
                const canvas = document.getElementById('convergenceChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxSum = Math.max(...convergenceData.map(d => d.maxSum));
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw convergence line
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                convergenceData.forEach((point, i) => {
                    const x = padding + (i / (convergenceData.length - 1)) * width;
                    const y = canvas.height - padding - (point.maxSum / maxSum) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('Iteration', canvas.width / 2 - 20, canvas.height - 10);
            }

            drawScatterPlot(results, sqrtN) {
                const canvas = document.getElementById('scatterChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxRatio = Math.max(...results.map(r => r.sum / sqrtN));
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw y = 1 reference line
                const refY = canvas.height - padding - (1 / maxRatio) * height;
                ctx.strokeStyle = '#ff6b6b';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(padding, refY);
                ctx.lineTo(canvas.width - padding, refY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Plot points
                results.slice(0, 100).forEach(result => {
                    const x = padding + (result.alpha * width);
                    const ratio = result.sum / sqrtN;
                    const y = canvas.height - padding - (ratio / maxRatio) * height;
                    
                    ctx.fillStyle = result.type === 'Major Arc' ? '#ff6b6b' : '#4ecdc4';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('α value', canvas.width / 2 - 20, canvas.height - 10);
                ctx.fillText('Ratio = 1', canvas.width - 80, refY - 5);
            }

            drawHistogram(results) {
                const canvas = document.getElementById('histogramChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                // Create histogram bins
                const bins = 20;
                const sums = results.map(r => r.sum);
                const minSum = Math.min(...sums);
                const maxSum = Math.max(...sums);
                const binWidth = (maxSum - minSum) / bins;
                const binCounts = new Array(bins).fill(0);
                
                sums.forEach(sum => {
                    const binIndex = Math.min(Math.floor((sum - minSum) / binWidth), bins - 1);
                    binCounts[binIndex]++;
                });
                
                const maxCount = Math.max(...binCounts);
                const barWidth = width / bins;
                
                // Draw bars
                binCounts.forEach((count, i) => {
                    const barHeight = (count / maxCount) * height;
                    const x = padding + i * barWidth;
                    const y = canvas.height - padding - barHeight;
                    
                    ctx.fillStyle = '#4ecdc4';
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                });
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('|S(N,α)| value', canvas.width / 2 - 30, canvas.height - 10);
            }

            isSimpleRational(alpha) {
                const tolerance = 1e-8;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        // Initialize the enhanced application
        const enhancedTester = new EnhancedRiemannHypothesisTester();

        // Global functions for UI interactions
        function setPreset(value) {
            document.getElementById('customN').value = value;
            updatePerformanceIndicator(value);
            
            // Auto-optimize parameters for large N to prevent memory issues
            if (value >= 50000000) {
                document.getElementById('numSamples').value = '50';
                document.getElementById('maxDenom').value = '8';
                document.getElementById('gridSize').value = '32';
            } else if (value >= 10000000) {
                document.getElementById('numSamples').value = '75';
                document.getElementById('maxDenom').value = '10';
                document.getElementById('gridSize').value = '48';
            } else if (value >= 1000000) {
                document.getElementById('numSamples').value = '100';
                document.getElementById('maxDenom').value = '12';
                document.getElementById('gridSize').value = '64';
            } else {
                document.getElementById('numSamples').value = '150';
                document.getElementById('maxDenom').value = '15';
                document.getElementById('gridSize').value = '64';
            }
        }

        function updatePerformanceIndicator(n) {
            const indicator = document.getElementById('performanceIndicator');
            
            if (n < 100000) {
                indicator.className = 'performance-indicator perf-excellent';
                indicator.innerHTML = '⚡ Excellent performance expected (< 1 second)';
            } else if (n < 1000000) {
                indicator.className = 'performance-indicator perf-good';
                indicator.innerHTML = '🟢 Good performance expected (1-3 seconds)';
            } else if (n < 10000000) {
                indicator.className = 'performance-indicator perf-warning';
                indicator.innerHTML = '🟡 Moderate performance expected (5-15 seconds)';
            } else {
                indicator.className = 'performance-indicator perf-danger';
                indicator.innerHTML = '🔴 Slower performance expected (15+ seconds)';
            }
        }

        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab and activate button
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function exportResults(format) {
            if (!enhancedTester.currentTest) {
                alert('No test results to export. Please run a test first.');
                return;
            }
            
            const results = enhancedTester.currentTest;
            let content = '';
            let filename = '';
            let mimeType = '';
            
            switch (format) {
                case 'csv':
                    content = 'Alpha,Sum,Ratio,Type,Phase,Real,Imaginary\n';
                    results.results.forEach(r => {
                        content += `${r.alpha},${r.sum},${r.sum/results.sqrtN},${r.type},${r.phase},${r.real},${r.imaginary}\n`;
                    });
                    filename = `riemann_test_${results.maxN}.csv`;
                    mimeType = 'text/csv';
                    break;
                    
                case 'json':
                    content = JSON.stringify(results, null, 2);
                    filename = `riemann_test_${results.maxN}.json`;
                    mimeType = 'application/json';
                    break;
                    
                case 'txt':
                    content = `Enhanced Riemann Hypothesis Test Report\n`;
                    content += `==========================================\n\n`;
                    content += `Test Parameters:\n`;
                    content += `- Maximum N: ${results.maxN.toLocaleString()}\n`;
                    content += `- √N bound: ${results.sqrtN.toFixed(6)}\n`;
                    content += `- Maximum |S(N,α)|: ${results.maxSum.toFixed(6)}\n`;
                    content += `- Ratio: ${results.ratio.toFixed(8)}\n`;
                    content += `- Best α: ${enhancedTester.formatAlpha(results.bestAlpha)}\n`;
                    content += `- Computation time: ${(results.computeTime/1000).toFixed(3)}s\n\n`;
                    
                    content += `Statistical Summary:\n`;
                    if (results.statistics) {
                        content += `- Mean: ${results.statistics.mean.toFixed(6)}\n`;
                        content += `- Standard deviation: ${results.statistics.stdDev.toFixed(6)}\n`;
                        content += `- Skewness: ${results.statistics.skewness.toFixed(4)}\n`;
                        content += `- Major arc results: ${results.statistics.majorArcCount}\n`;
                    }
                    
                    content += `\nTop 10 Results:\n`;
                    results.results.slice(0, 10).forEach((r, i) => {
                        content += `${i+1}. α=${enhancedTester.formatAlpha(r.alpha)}, |S|=${r.sum.toFixed(6)}, ratio=${(r.sum/results.sqrtN).toFixed(6)}, type=${r.type}\n`;
                    });
                    
                    filename = `riemann_test_report_${results.maxN}.txt`;
                    mimeType = 'text/plain';
                    break;
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportVisualization() {
            const canvas = document.getElementById('sumChart');
            const url = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = url;
            a.download = 'riemann_visualization.png';
            a.click();
        }

        // Event listeners
        document.getElementById('startTest').addEventListener('click', async function() {
            if (enhancedTester.isComputing) return;
            
            enhancedTester.isComputing = true;
            const button = document.getElementById('startTest');
            button.disabled = true;
            button.textContent = 'Computing...';
            document.body.classList.add('computing');
            
            // Get parameters
            const maxN = parseInt(document.getElementById('customN').value);
            const testMode = document.getElementById('testMode').value;
            const numSamples = parseInt(document.getElementById('numSamples').value);
            const maxDenom = parseInt(document.getElementById('maxDenom').value);
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const precision = document.getElementById('precisionLevel').value;
            
            const options = {
                showDetails: document.getElementById('showDetails').checked,
                generateHeatmap: document.getElementById('generateHeatmap').checked,
                showStatistics: document.getElementById('showStatistics').checked,
                realTimeUpdates: document.getElementById('realTimeUpdates').checked,
                enablePhaseAnalysis: document.getElementById('enablePhaseAnalysis').checked,
                enableDistributionAnalysis: document.getElementById('enableDistributionAnalysis').checked,
                enableFrequencyAnalysis: document.getElementById('enableFrequencyAnalysis').checked
            };
            
            // Validate input
            if (isNaN(maxN) || maxN < 1 || maxN > 100000000) {
                alert('Please enter a valid number between 1 and 100,000,000');
                enhancedTester.isComputing = false;
                button.disabled = false;
                button.textContent = '🚀 Launch Enhanced Cosmic Test';
                document.body.classList.remove('computing');
                return;
            }
            
            try {
                const results = await enhancedTester.runEnhancedVerification(maxN, testMode, numSamples, maxDenom, gridSize, precision, options);
                enhancedTester.displayEnhancedResults(results);
            } catch (error) {
                console.error('Enhanced computation error:', error);
                alert('An error occurred during computation. Please try again with smaller parameters.');
            }
            
            enhancedTester.isComputing = false;
            button.disabled = false;
            button.textContent = '🚀 Launch Enhanced Cosmic Test';
            document.body.classList.remove('computing');
        });

        // Input validation and performance updates
        document.getElementById('customN').addEventListener('input', function() {
            const value = parseInt(this.value);
            
            if (value > 100000000) {
                this.value = 100000000;
            } else if (value < 1) {
                this.value = 1;
            }
            
            updatePerformanceIndicator(parseInt(this.value));
            
            // Auto-optimize for very large values
            if (value > 25000000) {
                setPreset(value);
            }
        });

        // Initialize with default performance indicator
        updatePerformanceIndicator(1000000);
    </script>
</body>
</html>        .subtitle {
            text-align: center;
            color: #a0a0a0;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(40, 40, 60, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #4ecdc4;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #c0c0c0;
        }
        
        input, select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            box-sizing: border-box;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.1);
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .preset-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px 12px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            margin-top: 0;
            width: auto;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .results {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .results h3 {
            margin-top: 0;
            color: #4ecdc4;
            border-bottom: 2px solid #4ecdc4;
            padding-bottom: 10px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(20, 20, 30, 0.5);
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
        }
        
        .metric-label {
            font-weight: 500;
            color: #c0c0c0;
        }
        
        .metric-value {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .math-formula {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
        }
        
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .status.computing {
            background: rgba(255, 243, 205, 0.2);
            color: #feca57;
            border: 1px solid #feca57;
        }
        
        .status.complete {
            background: rgba(209, 236, 241, 0.2);
            color: #4ecdc4;
            border: 1px solid #4ecdc4;
        }

        .cosmic-status {
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border: 2px solid;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-cosmic {
            background: linear-gradient(45deg, rgba(255, 107, 107, 0.2), rgba(238, 90, 82, 0.2));
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .status-legendary {
            background: linear-gradient(45deg, rgba(255, 154, 86, 0.2), rgba(255, 123, 123, 0.2));
            border-color: #ff9a56;
            color: #ff9a56;
        }

        .status-mythical {
            background: linear-gradient(45deg, rgba(78, 205, 196, 0.2), rgba(68, 160, 141, 0.2));
            border-color: #4ecdc4;
            color: #4ecdc4;
        }

        .status-excellent {
            background: linear-gradient(45deg, rgba(150, 206, 180, 0.2), rgba(68, 160, 141, 0.2));
            border-color: #96ceb4;
            color: #96ceb4;
        }

        .status-good {
            background: linear-gradient(45deg, rgba(254, 202, 87, 0.2), rgba(255, 159, 67, 0.2));
            border-color: #feca57;
            color: #feca57;
        }

        .status-high {
            background: linear-gradient(45deg, rgba(255, 154, 86, 0.2), rgba(255, 107, 107, 0.2));
            border-color: #ff9a56;
            color: #ff9a56;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .visualization-item {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .visualization-item h4 {
            color: #4ecdc4;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        canvas {
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        
        .computing-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #4ecdc4;
            border-radius: 50%;
            animation: pulse 1s infinite;
            margin-left: 5px;
        }
        
        .chart-info {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid #4ecdc4;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            min-height: 60px;
        }
        
        .chart-info-title {
            color: #4ecdc4;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .chart-tooltip {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            border: 1px solid #4ecdc4;
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 200px;
        }
        
        .theory-box {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1));
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #4ecdc4;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }
        
        .theory-box h4 {
            margin-top: 0;
            color: #4ecdc4;
        }

        .detailed-results {
            margin-top: 20px;
            background: rgba(20, 20, 30, 0.9);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .results-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #c0c0c0;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 0;
            width: auto;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
            border-color: #4ecdc4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .top-results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .top-results-table th,
        .top-results-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        .top-results-table th {
            background: rgba(78, 205, 196, 0.2);
            color: #4ecdc4;
        }

        .insights {
            background: rgba(78, 205, 196, 0.1);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #4ecdc4;
        }

        .heatmap-container {
            text-align: center;
            margin: 20px 0;
        }

        .heatmap-legend {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .statistics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(20, 20, 30, 0.8);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #4ecdc4;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #45b7d1, #96ceb4);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin-top: 0;
            width: auto;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(69, 183, 209, 0.4);
        }
        
        @keyframes computing {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .computing button {
            animation: computing 2s infinite;
        }

        small {
            color: #a0a0a0;
            font-size: 12px;
            display: block;
            margin-top: 5px;
        }

        .advanced-options {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .performance-indicator {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid;
        }

        .perf-excellent {
            background: rgba(78, 205, 196, 0.1);
            border-color: #4ecdc4;
            color: #4ecdc4;
        }

        .perf-good {
            background: rgba(150, 206, 180, 0.1);
            border-color: #96ceb4;
            color: #96ceb4;
        }

        .perf-warning {
            background: rgba(254, 202, 87, 0.1);
            border-color: #feca57;
            color: #feca57;
        }

        .perf-danger {
            background: rgba(255, 107, 107, 0.1);
            border-color: #ff6b6b;
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1> Enhanced Cosmic Scale Riemann Hypothesis Tester</h1>
        <p class="subtitle">Advanced Browser-Based Computational Testing with Comprehensive Analysis - Up to 100 Million Points</p>
        
        <div class="theory-box">
            <h4>The Riemann Hypothesis - One of Mathematics' Greatest Mysteries</h4>
            <p>The Riemann Hypothesis, proposed by Bernhard Riemann in 1859, is one of the most important unsolved problems in mathematics. It concerns the distribution of prime numbers and has profound implications for number theory, cryptography, and our understanding of mathematical patterns.</p>
            
            <div class="math-formula">
                S(N,α) = Σ<sub>n≤N</sub> μ(n) · e<sup>2πinα</sup>
            <div class="theory-box">
            <h4> The Riemann Zeta Function and Its Critical Zeros</h4>
            
            <div style="background: rgba(69, 183, 209, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h5 style="color: #45b7d1; margin-top: 0;">The Zeta Function Defined</h5>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 16px; margin: 15px 0;">
                    ζ(s) = Σ<sub>n=1</sub><sup>∞</sup> 1/n<sup>s</sup> = 1 + 1/2<sup>s</sup> + 1/3<sup>s</sup> + 1/4<sup>s</sup> + ...
                <div class="theory-box">
            <h4>Enhanced by Wessen Getachew</h4>
            <p><strong>Creator:</strong> Wessen Getachew (<a href="https://twitter.com/7dview" target="_blank" style="color: #4ecdc4;">@7dview</a>)</p>
            <p><strong>Mathematical Framework:</strong> Based on classical work by Davenport, Halberstam, Montgomery, and modern computational number theory</p>
            <p><strong>Implementation:</strong> Advanced JavaScript algorithms with comprehensive visualization and interactive analysis for browser-based scientific computing</p>
            <p><strong>Special thanks to:</strong> The open mathematics community, Andrew Odlyzko's computational work, Xavier Gourdon's large-scale verifications, and all researchers who have contributed to our understanding of the Riemann Hypothesis</p>
        </div>
                <p style="margin: 10px 0; font-size: 13px;">Where <strong>s = σ + it</strong> is a complex number with real part σ and imaginary part t</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">For Real s > 1:</h6>
                        <p style="margin: 0; font-size: 12px;">Series converges absolutely<br>ζ(2) = π²/6, ζ(4) = π⁴/90</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">For σ < 1:</h6>
                        <p style="margin: 0; font-size: 12px;">Analytic continuation needed<br>Functional equation relates ζ(s) to ζ(1-s)</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h6 style="color: #45b7d1; margin: 0 0 5px 0;">The Critical Strip:</h6>
                        <p style="margin: 0; font-size: 12px;">0 < σ < 1<br>Where non-trivial zeros live</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🎯 The Critical Zeros and Prime Connection</h5>
            
            <div style="background: rgba(255, 107, 107, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #ff6b6b; margin-top: 0;">Euler's Product Formula (The Bridge to Primes)</h6>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 14px; margin: 10px 0;">
                    ζ(s) = Π<sub>p prime</sub> 1/(1 - 1/p<sup>s</sup>)
                </div>
                <p style="margin: 10px 0; font-size: 13px;"><strong>This is why ζ(s) encodes all information about primes!</strong> Every prime p contributes a factor to the infinite product.</p>
            </div>
            
            <div style="background: rgba(254, 202, 87, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #feca57; margin-top: 0;">The Explicit Formula (How Zeros Control Primes)</h6>
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 14px; margin: 10px 0;">
                    π(x) = Li(x) - Σ<sub>ρ</sub> Li(x<sup>ρ</sup>) + O(x<sup>1/2</sup>)
                </div>
                <p style="margin: 10px 0; font-size: 13px;">Where ρ = 1/2 + it are the <strong>critical zeros</strong>. Each zero ρ contributes an oscillatory term Li(x<sup>ρ</sup>) to the prime counting function!</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div>
                        <h7 style="color: #feca57; font-weight: bold;">If RH is True (all zeros on σ = 1/2):</h7>
                        <ul style="margin: 5px 0; padding-left: 15px; font-size: 12px;">
                            <li>|π(x) - Li(x)| ≪ √x ln(x)</li>
                            <li>Prime gaps ≪ √p ln(p)</li>
                            <li>Oscillations are "balanced"</li>
                        </ul>
                    </div>
                    <div>
                        <h7 style="color: #ff6b6b; font-weight: bold;">If RH is False (zeros off the line):</h7>
                        <ul style="margin: 5px 0; padding-left: 15px; font-size: 12px;">
                            <li>Larger deviations possible</li>
                            <li>Prime distribution less regular</li>
                            <li>Cryptographic implications</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;"> How Our Möbius Verification Connects to Zeros</h5>
            
            <div style="background: rgba(78, 205, 196, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h6 style="color: #4ecdc4; margin-top: 0;">The Deep Connection</h6>
                <p style="margin: 10px 0; font-size: 13px;">Our exponential sums S(N,α) = Σ μ(n)e<sup>2πinα</sup> are related to the zeta zeros through:</p>
                
                <div style="text-align: center; font-family: 'Times New Roman', serif; font-size: 13px; margin: 15px 0; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px;">
                    Σ<sub>n≤x</sub> μ(n) = Σ<sub>ρ</sub> x<sup>ρ</sup>/ρ ζ'(ρ)/ζ(ρ) + lower order terms
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h7 style="color: #4ecdc4; font-weight: bold;">When |S(N,α)| is small:</h7>
                        <p style="margin: 5px 0; font-size: 12px;">• Zeros are behaving "as expected"<br>• Cancellation is working properly<br>• RH predictions hold</p>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 10px; border-radius: 6px;">
                        <h7 style="color: #ff6b6b; font-weight: bold;">When |S(N,α)| is large:</h7>
                        <p style="margin: 5px 0; font-size: 12px;">• Possible resonance effects<br>• Zero distribution anomalies<br>• Interesting mathematics!</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">🌐 The Complete Picture: All s Values</h5>
            
            <div style="background: linear-gradient(135deg, rgba(150, 206, 180, 0.1), rgba(68, 160, 141, 0.1)); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;"> Trivial Zeros (s = -2, -4, -6, ...)</h6>
                        <p style="margin: 0; font-size: 12px;">At negative even integers. These come from the functional equation and are well understood. They don't affect prime distribution significantly.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;"> Critical Zeros (σ = 1/2 + it)</h6>
                        <p style="margin: 0; font-size: 12px;"><strong>The stars of the show!</strong> These control prime distribution. RH says they ALL lie on the critical line σ = 1/2.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;"> The Critical Strip (0 < σ < 1)</h6>
                        <p style="margin: 0; font-size: 12px;">If any non-trivial zeros exist off the line σ = 1/2 but in this strip, RH fails and prime behavior becomes less predictable.</p>
                    </div>
                    
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 10px 0;"> Functional Equation</h6>
                        <p style="margin: 0; font-size: 12px;">ζ(s) = 2<sup>s</sup>π<sup>s-1</sup>sin(πs/2)Γ(1-s)ζ(1-s)<br>Relates values at s and 1-s</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;"> Known Zero Statistics</h5>
            
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0; font-size: 12px;">
                <tr style="background: rgba(255,255,255,0.1);">
                    <th style="padding: 8px; border: 1px solid #666;">Height Range</th>
                    <th style="padding: 8px; border: 1px solid #666;">Zeros Computed</th>
                    <th style="padding: 8px; border: 1px solid #666;">All on σ = 1/2?</th>
                    <th style="padding: 8px; border: 1px solid #666;">Computational Effort</th>
                </tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 100</td><td style="padding: 6px; border: 1px solid #666;">29</td><td style="padding: 6px; border: 1px solid #666;">✅ Yes</td><td style="padding: 6px; border: 1px solid #666;">By hand (Riemann era)</td></tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 10,000</td><td style="padding: 6px; border: 1px solid #666;">~3,000</td><td style="padding: 6px; border: 1px solid #666;">✅ Yes</td><td style="padding: 6px; border: 1px solid #666;">Early computers</td></tr>
                <tr><td style="padding: 6px; border: 1px solid #666;">0 < t < 10¹³</td><td style="padding: 6px; border: 1px solid #666;">~10¹³</td><td style="padding: 6px; border: 1px solid #666;">✅ Yes</td><td style="padding: 6px; border: 1px solid #666;">Modern supercomputers</td></tr>
            </table>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;"> The Beautiful Harmony</h5>
            
            <div style="background: rgba(69, 183, 209, 0.1); border: 1px solid rgba(69, 183, 209, 0.3); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <p style="margin: 0; font-style: italic; font-size: 14px;"><strong>The zeros of ζ(s) are like the "harmonics" of the prime number "symphony."</strong></p>
                
                <ul style="margin: 10px 0; padding-left: 20px; font-size: 13px;">
                    <li><strong>Each zero ρ = 1/2 + it</strong> contributes an oscillation Li(x<sup>ρ</sup>) = Li(x<sup>1/2+it</sup>) to the prime counting function</li>
                    <li><strong>The imaginary parts t</strong> determine the "frequencies" of oscillation in prime distribution</li>
                    <li><strong>If all zeros are on σ = 1/2,</strong> these oscillations are perfectly balanced and cancel optimally</li>
                    <li><strong>Our Möbius verification</strong> checks that this cancellation is working as RH predicts</li>
                </ul>
                
                <div style="text-align: center; margin: 15px 0; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                    <strong>Every small ratio |S(N,α)|/√N we compute is evidence that the zeros are singing in perfect harmony! 🎵</strong>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;"> What Our Verification Specifically Tests</h5>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 12px;">
                    <h6 style="color: #ff6b6b; margin: 0 0 8px 0;">Direct Zero Impact</h6>
                    <p style="margin: 0; font-size: 12px;">Our sums are directly influenced by zeros with imaginary parts t ≈ α·N/(2π). We're probing the zero distribution!</p>
                </div>
                
                <div style="background: rgba(254, 202, 87, 0.1); border-left: 4px solid #feca57; padding: 12px;">
                    <h6 style="color: #feca57; margin: 0 0 8px 0;">Cancellation Quality</h6>
                    <p style="margin: 0; font-size: 12px;">Small ratios mean the zeros are creating the precise cancellations needed for RH error bounds.</p>
                </div>
                
                <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 12px;">
                    <h6 style="color: #4ecdc4; margin: 0 0 8px 0;">Statistical Behavior</h6>
                    <p style="margin: 0; font-size: 12px;">The distribution of our results reflects the statistical properties of zeros predicted by random matrix theory.</p>
                </div>
            </div>
            
            <div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.15), rgba(68, 160, 141, 0.15)); border-radius: 10px; padding: 20px; margin: 20px 0; border: 2px solid rgba(78, 205, 196, 0.3);">
                <h6 style="color: #4ecdc4; margin: 0 0 15px 0; text-align: center; font-size: 16px;">🌟 The Grand Unification</h6>
                <p style="margin: 0; text-align: center; font-size: 14px; font-style: italic;">Our browser-based Möbius verification connects:</p>
                <div style="text-align: center; margin: 15px 0; line-height: 1.8;">
                    <strong>Riemann Zeta Zeros</strong> ↔ <strong>Prime Distribution</strong> ↔ <strong>Möbius Cancellation</strong> ↔ <strong>Cryptographic Security</strong>
                </div>
                <p style="margin: 15px 0 0 0; text-align: center; font-size: 13px;">Every test you run explores this magnificent mathematical symphony! 🎼</p>
            </div>
        </div>
            
            <p><strong>What we're testing:</strong> Under the Riemann Hypothesis, these Möbius exponential sums should satisfy |S(N,α)| = O(√N) uniformly in α. If we find ratios significantly larger than √N, it could indicate interesting mathematical phenomena or even contradict RH predictions.</p>
            
            <h4>The Möbius Function μ(n)</h4>
            <p>The Möbius function is defined as:</p>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li><strong>μ(n) = 1</strong> if n is a square-free positive integer with an even number of prime factors</li>
                <li><strong>μ(n) = -1</strong> if n is a square-free positive integer with an odd number of prime factors</li>
                <li><strong>μ(n) = 0</strong> if n has a squared prime factor</li>
            </ul>
            <p>Examples: μ(1)=1, μ(2)=-1, μ(3)=-1, μ(4)=0, μ(6)=1, μ(12)=0</p>
        </div>
        
        <div class="theory-box">
            <h4>Historical Context & Significance</h4>
            <p><strong>Prime Number Connection:</strong> The hypothesis directly relates to how accurately we can predict the distribution of prime numbers. If true, it provides the best possible bounds for counting primes.</p>
            
            <p><strong>Cryptographic Implications:</strong> Many modern encryption systems rely on the difficulty of factoring large numbers. RH predictions help us understand the security foundations of these systems.</p>
            
            <p><strong>Computational Verification:</strong> The hypothesis has been verified for the first 10<sup>13</sup> zeros, but a general proof remains one of mathematics' greatest challenges.</p>
        </div>
        
        <div class="theory-box">
            <h4> What This Tells Us About Prime Numbers</h4>
            
            <div style="background: rgba(78, 205, 196, 0.1); border-radius: 8px; padding: 15px; margin: 15px 0;">
                <h5 style="color: #4ecdc4; margin-top: 0;">The Gauss-Legendre Connection</h5>
                <p><strong>π(x)</strong> = actual count of primes ≤ x &nbsp;|&nbsp; <strong>Li(x)</strong> = logarithmic integral ≈ x/ln(x)</p>
                <p><strong>Historic Insight:</strong> In 1792, 15-year-old Gauss predicted π(x) ≈ Li(x). Our RH verification directly validates this prediction!</p>
                
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0; font-size: 12px;">
                    <tr style="background: rgba(255,255,255,0.1);">
                        <th style="padding: 8px; border: 1px solid #666;">x</th>
                        <th style="padding: 8px; border: 1px solid #666;">π(x) actual</th>
                        <th style="padding: 8px; border: 1px solid #666;">Li(x) Gauss</th>
                        <th style="padding: 8px; border: 1px solid #666;">Error</th>
                        <th style="padding: 8px; border: 1px solid #666;">Error %</th>
                    </tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10³</td><td style="padding: 6px; border: 1px solid #666;">168</td><td style="padding: 6px; border: 1px solid #666;">178</td><td style="padding: 6px; border: 1px solid #666;">+10</td><td style="padding: 6px; border: 1px solid #666;">5.9%</td></tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10⁶</td><td style="padding: 6px; border: 1px solid #666;">78,498</td><td style="padding: 6px; border: 1px solid #666;">78,628</td><td style="padding: 6px; border: 1px solid #666;">+130</td><td style="padding: 6px; border: 1px solid #666;">0.17%</td></tr>
                    <tr><td style="padding: 6px; border: 1px solid #666;">10⁹</td><td style="padding: 6px; border: 1px solid #666;">50,847,534</td><td style="padding: 6px; border: 1px solid #666;">50,849,235</td><td style="padding: 6px; border: 1px solid #666;">+1,701</td><td style="padding: 6px; border: 1px solid #666;">0.003%</td></tr>
                </table>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">How Our Verification Validates Prime Behavior</h5>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 15px 0;">
                <div style="background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; padding: 10px;">
                    <h6 style="color: #ff6b6b; margin: 0 0 8px 0;"> When Ratio < 1.0</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Prime gaps stay close to ln(x)</li>
                        <li>No large "prime deserts"</li>
                        <li>Gauss's formula is highly accurate</li>
                        <li>Cryptographic security is strong</li>
                    </ul>
                </div>
                
                <div style="background: rgba(254, 202, 87, 0.1); border-left: 4px solid #feca57; padding: 10px;">
                    <h6 style="color: #feca57; margin: 0 0 8px 0;"> Major Arc Dominance</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Primes in arithmetic progressions behave regularly</li>
                        <li>Dirichlet's theorem is validated</li>
                        <li>Twin prime patterns follow predictions</li>
                        <li>Hardy-Littlewood conjectures gain support</li>
                    </ul>
                </div>
                
                <div style="background: rgba(78, 205, 196, 0.1); border-left: 4px solid #4ecdc4; padding: 10px;">
                    <h6 style="color: #4ecdc4; margin: 0 0 8px 0;"> Low Variance Results</h6>
                    <ul style="margin: 0; padding-left: 15px; font-size: 13px;">
                        <li>Primes avoid excessive clustering</li>
                        <li>Cramér's conjecture gains support</li>
                        <li>Random matrix connections validated</li>
                        <li>Prime Number Theorem error bounds tight</li>
                    </ul>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">Real-World Applications</h5>
            <div style="background: rgba(150, 206, 180, 0.1); border-radius: 8px; padding: 15px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;"> Cryptography</h6>
                        <p style="margin: 0; font-size: 12px;">RSA security, prime generation, key sizing, factoring difficulty bounds</p>
                    </div>
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;"> Algorithms</h6>
                        <p style="margin: 0; font-size: 12px;">Primality testing, hash functions, pseudorandom generators, sieve optimization</p>
                    </div>
                    <div>
                        <h6 style="color: #96ceb4; margin: 0 0 5px 0;"> Mathematics</h6>
                        <p style="margin: 0; font-size: 12px;">L-functions, automorphic forms, analytic number theory, additive combinatorics</p>
                    </div>
                </div>
            </div>
            
            <h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">What Our Möbius Sums Reveal</h5>
            <p>The exponential sums S(N,α) = Σ μ(n)e^(2πinα) are intimately connected to prime distribution through:</p>
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 15px; font-family: 'Courier New', monospace; margin: 10px 0;">
                <div style="text-align: center; margin-bottom: 10px;">π(x) = Li(x) - Σ<sub>ρ</sub> Li(x<sup>ρ</sup>) + O(x<sup>θ</sup>)</div>
                <div style="font-size: 11px; text-align: center; color: #a0a0a0;">Riemann's exact prime counting formula</div>
            </div>
            <ul style="font-size: 13px; margin: 10px 0;">
                <li><strong>Small ratios |S(N,α)|/√N:</strong> Error terms π(x) - Li(x) are controlled ≪ √x ln(x)</li>
                <li><strong>Major arc peaks:</strong> Primes in arithmetic progressions follow Dirichlet predictions</li>
                <li><strong>Smooth convergence:</strong> No chaotic behavior - primes are "well-distributed"</li>
                <li><strong>Low variance:</strong> Prime gaps stay near logarithmic average</li>
            </ul>
            
            <div style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(68, 160, 141, 0.1)); border-radius: 8px; padding: 15px; margin: 15px 0; border: 1px solid rgba(78, 205, 196, 0.3);">
                <h6 style="color: #4ecdc4; margin: 0 0 10px 0;"> The Beautiful Connection</h6>
                <p style="margin: 0; font-style: italic;">Every successful RH verification means: <strong>"Primes are distributed so regularly that a teenager's 1792 intuition predicts their count to within √N accuracy!"</strong></p>
                <p style="margin: 10px 0 0 0; font-size: 12px;">When you see smooth, low-ratio visualizations, you're witnessing computational proof that the universe's prime distribution follows deep, predictable patterns that Gauss intuited over 230 years ago.</p>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3> Test Configuration</h3>
                
                <label for="maxN">Maximum N:</label>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="setPreset(100000)">100K</button>
                    <button class="preset-btn" onclick="setPreset(500000)">500K</button>
                    <button class="preset-btn" onclick="setPreset(1000000)">1M</button>
                    <button class="preset-btn" onclick="setPreset(5000000)">5M</button>
                    <button class="preset-btn" onclick="setPreset(10000000)">10M</button>
                    <button class="preset-btn" onclick="setPreset(25000000)">25M</button>
                    <button class="preset-btn" onclick="setPreset(50000000)">50M</button>
                    <button class="preset-btn" onclick="setPreset(100000000)">100M</button>
                </div>
                <input type="number" id="customN" value="1000000" min="1" max="100000000" placeholder="Enter custom N value">
                
                <div id="performanceIndicator" class="performance-indicator perf-excellent">
                     Excellent performance expected (~1-2 seconds)
                </div>
                
                <label for="testMode">Test Mode:</label>
                <select id="testMode">
                    <option value="stochastic">Stochastic α sampling</option>
                    <option value="major-arcs" selected>Major arcs analysis</option>
                    <option value="uniform">Uniform grid</option>
                    <option value="comprehensive">Comprehensive (all methods)</option>
                    <option value="adaptive">Adaptive precision</option>
                </select>
            </div>
            
            <div class="control-group">
                <h3> Sampling Parameters</h3>
                
                <div class="two-column">
                    <div>
                        <label for="numSamples">Number of α samples:</label>
                        <input type="number" id="numSamples" value="100" min="10" max="2000">
                        <small>More samples = better coverage</small>
                    </div>
                    
                    <div>
                        <label for="maxDenom">Max denominator (major arcs):</label>
                        <input type="number" id="maxDenom" value="12" min="2" max="50">
                        <small>Higher values test more rational α = a/q</small>
                    </div>
                </div>
                
                <div class="two-column">
                    <div>
                        <label for="gridSize">Grid size (uniform mode):</label>
                        <input type="number" id="gridSize" value="64" min="8" max="256">
                        <small>Grid resolution for uniform sampling</small>
                    </div>
                    
                    <div>
                        <label for="precisionLevel">Precision level:</label>
                        <select id="precisionLevel">
                            <option value="standard">Standard</option>
                            <option value="high" selected>High</option>
                            <option value="ultra">Ultra (slow)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3> Visualization & Analysis</h3>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showDetails" checked>
                    <label for="showDetails">Show detailed analysis</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="generateHeatmap" checked>
                    <label for="generateHeatmap">Generate complexity heatmap</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="showStatistics" checked>
                    <label for="showStatistics">Statistical analysis</label>
                </div>
                
                <div class="checkbox-group">
                    <input type="checkbox" id="realTimeUpdates">
                    <label for="realTimeUpdates">Real-time progress updates</label>
                </div>
                
                <div class="advanced-options">
                    <h4 style="margin-top: 0; color: #96ceb4;">Advanced Options</h4>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enablePhaseAnalysis">
                        <label for="enablePhaseAnalysis">Phase analysis</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableDistributionAnalysis">
                        <label for="enableDistributionAnalysis">Distribution analysis</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="enableFrequencyAnalysis">
                        <label for="enableFrequencyAnalysis">Frequency domain analysis</label>
                    </div>
                </div>
                
                <button id="startTest"> Launch Enhanced Cosmic Test</button>
            </div>
        </div>
        
        <div class="progress-container" id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="statusText" class="status computing">Initializing enhanced computation...</div>
        </div>
        
        <div class="results" id="results" style="display: none;">
            <h3> Enhanced Cosmic Verification Results</h3>
            
            <div class="metrics-grid">
                <div class="metric">
                    <span class="metric-label">Maximum N tested:</span>
                    <span class="metric-value" id="resultN">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">√N (theoretical bound):</span>
                    <span class="metric-value" id="resultSqrtN">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Maximum |S(N,α)| found:</span>
                    <span class="metric-value" id="resultMaxSum">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Ratio |S(N,α)|/√N:</span>
                    <span class="metric-value" id="resultRatio">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Best α value:</span>
                    <span class="metric-value" id="resultBestAlpha">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Computation time:</span>
                    <span class="metric-value" id="computeTime">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Operations per second:</span>
                    <span class="metric-value" id="opsPerSec">-</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Memory efficiency:</span>
                    <span class="metric-value" id="memoryEff">-</span>
                </div>
            </div>

            <div class="cosmic-status" id="cosmicStatus" style="display: none;">
                 Status will appear here
            </div>
            
            <div id="statisticalSummary" style="display: none;">
                <h4 style="color: #4ecdc4; margin-bottom: 15px;">Statistical Summary</h4>
                <div class="statistics-grid" id="statsGrid">
                    <!-- Statistics will be populated here -->
                </div>
            </div>
            
            <div id="detailedResults" style="display: none;" class="detailed-results">
                <div class="results-tabs">
                    <button class="tab-button active" onclick="switchTab('topResults')">Top Results</button>
                    <button class="tab-button" onclick="switchTab('insights')">Mathematical Insights</button>
                    <button class="tab-button" onclick="switchTab('distribution')">Distribution Analysis</button>
                    <button class="tab-button" onclick="switchTab('phase')">Phase Analysis</button>
                    <button class="tab-button" onclick="switchTab('export')">Export Data</button>
                </div>
                
                <div id="topResults" class="tab-content active">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Top Exponential Sum Values</h4>
                    <table class="top-results-table" id="topResultsTable">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>α value</th>
                                <th>|S(N,α)|</th>
                                <th>Ratio</th>
                                <th>Type</th>
                            </tr>
                        </thead>
                        <tbody id="topResultsBody">
                        </tbody>
                    </table>
                </div>
                
                <div id="insights" class="tab-content">
                    <div class="insights">
                        <h5 style="color: #4ecdc4; margin-bottom: 10px;">Mathematical Insights</h5>
                        <div id="insightsContent">
                            <p>Complete a test to see detailed analysis and insights.</p>
                        </div>
                    </div>
                </div>
                
                <div id="distribution" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Distribution Analysis</h4>
                    <div id="distributionAnalysis">
                        <p>Distribution analysis will appear here after computation.</p>
                    </div>
                </div>
                
                <div id="phase" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Phase Analysis</h4>
                    <div id="phaseAnalysis">
                        <p>Phase analysis will appear here after computation.</p>
                    </div>
                </div>
                
                <div id="export" class="tab-content">
                    <h4 style="color: #4ecdc4; margin-bottom: 15px;">Export Data</h4>
                    <div class="export-buttons">
                        <button class="export-btn" onclick="exportResults('csv')">📄 Export CSV</button>
                        <button class="export-btn" onclick="exportResults('json')">📋 Export JSON</button>
                        <button class="export-btn" onclick="exportResults('txt')">📝 Export Report</button>
                        <button class="export-btn" onclick="exportVisualization()">🖼️ Export Charts</button>
                    </div>
                    <p style="margin-top: 15px; color: #a0a0a0;">Export your results in various formats for further analysis or sharing.</p>
                </div>
            </div>
        </div>
        
        <div class="visualization-grid" id="visualizationGrid" style="display: none;">
            <div class="visualization-item">
                <h4>Exponential Sum Distribution</h4>
                <canvas id="sumChart" width="400" height="300"></canvas>
                <div class="chart-info" id="sumChartInfo">
                    <div class="chart-info-title">Click on points to see details</div>
                    <div id="sumChartDetails">Hover over data points or click for exact values</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Complexity Heatmap</h4>
                <div class="heatmap-container">
                    <canvas id="heatmapChart" width="400" height="300"></canvas>
                    <div class="chart-info" id="heatmapInfo">
                        <div class="chart-info-title">Heatmap Values</div>
                        <div id="heatmapDetails">Click on cells to see sum values</div>
                    </div>
                    <div class="heatmap-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4ecdc4;"></div>
                            <span>Low</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #feca57;"></div>
                            <span>Medium</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b6b;"></div>
                            <span>High</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Phase Distribution</h4>
                <canvas id="phaseChart" width="400" height="300"></canvas>
                <div class="chart-info" id="phaseChartInfo">
                    <div class="chart-info-title">Phase Analysis</div>
                    <div id="phaseChartDetails">Click on points to see phase and magnitude</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Convergence Analysis</h4>
                <canvas id="convergenceChart" width="400" height="300"></canvas>
                <div class="chart-info" id="convergenceChartInfo">
                    <div class="chart-info-title">Convergence Data</div>
                    <div id="convergenceChartDetails">Click on the line to see iteration details</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Ratio vs α Scatter Plot</h4>
                <canvas id="scatterChart" width="400" height="300"></canvas>
                <div class="chart-info" id="scatterChartInfo">
                    <div class="chart-info-title">Scatter Plot Data</div>
                    <div id="scatterChartDetails">Click on points to see α and ratio values</div>
                </div>
            </div>
            
            <div class="visualization-item">
                <h4>Statistical Distribution</h4>
                <canvas id="histogramChart" width="400" height="300"></canvas>
                <div class="chart-info" id="histogramInfo">
                    <div class="chart-info-title">Histogram Data</div>
                    <div id="histogramDetails">Click on bars to see frequency counts</div>
                </div>
            </div>
        </div>
        
        <!-- Tooltip for interactive charts -->
        <div class="chart-tooltip" id="chartTooltip"></div>
    </div>

    <script>
        class EnhancedRiemannHypothesisTester {
            constructor() {
                this.mobius = [];
                this.maxN = 0;
                this.isComputing = false;
                this.results = [];
                this.phaseData = [];
                this.convergenceData = [];
                this.currentTest = null;
            }

            // Optimized Möbius function computation using sieve method
            computeMobius(n) {
                console.log('Computing Möbius function up to ' + n + '...');
                const startTime = performance.now();
                
                this.mobius = new Int8Array(n + 1);
                const smallestPrimeFactor = new Array(n + 1).fill(0);
                
                // Initialize
                this.mobius[1] = 1;
                
                // Sieve to find smallest prime factors
                for (let i = 2; i <= n; i++) {
                    if (smallestPrimeFactor[i] === 0) {
                        // i is prime
                        smallestPrimeFactor[i] = i;
                        for (let j = i * i; j <= n; j += i) {
                            if (smallestPrimeFactor[j] === 0) {
                                smallestPrimeFactor[j] = i;
                            }
                        }
                    }
                }
                
                // Compute Möbius function using multiplicative property
                for (let i = 2; i <= n; i++) {
                    const p = smallestPrimeFactor[i];
                    const quotient = Math.floor(i / p);
                    
                    if (quotient % p === 0) {
                        // i is divisible by p², so μ(i) = 0
                        this.mobius[i] = 0;
                    } else {
                        // μ(i) = -μ(i/p) since p is the smallest prime factor
                        this.mobius[i] = -this.mobius[quotient];
                    }
                }
                
                const endTime = performance.now();
                console.log('Möbius computation completed in ' + (endTime - startTime).toFixed(2) + 'ms');
                this.maxN = n;
            }

            // Enhanced exponential sum computation with phase tracking
            computeExponentialSum(N, alpha, trackPhase = false) {
                let realSum = 0;
                let imagSum = 0;
                let phases = [];
                
                for (let n = 1; n <= N; n++) {
                    if (this.mobius[n] !== 0) {
                        const angle = 2 * Math.PI * n * alpha;
                        const cosVal = Math.cos(angle);
                        const sinVal = Math.sin(angle);
                        
                        realSum += this.mobius[n] * cosVal;
                        imagSum += this.mobius[n] * sinVal;
                        
                        if (trackPhase && n % Math.max(1, Math.floor(N / 50)) === 0) {
                            phases.push({
                                n: n,
                                phase: Math.atan2(imagSum, realSum),
                                magnitude: Math.sqrt(realSum * realSum + imagSum * imagSum),
                                alpha: alpha
                            });
                        }
                    }
                }
                
                const magnitude = Math.sqrt(realSum * realSum + imagSum * imagSum);
                const phase = Math.atan2(imagSum, realSum);
                
                return {
                    magnitude: magnitude,
                    phase: phase,
                    real: realSum,
                    imaginary: imagSum,
                    phases: phases
                };
            }

            // Generate enhanced α values based on mode and precision
            generateAlphaValues(mode, numSamples, maxDenom, gridSize, precision) {
                const alphas = [];
                
                switch (mode) {
                    case 'stochastic':
                        for (let i = 0; i < numSamples; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'major-arcs':
                        // Test rational numbers with small denominators
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                }
                            }
                        }
                        // Add some random values too
                        const randomCount = Math.min(Math.floor(numSamples / 2), 100);
                        for (let i = 0; i < randomCount; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'uniform':
                        for (let i = 0; i < gridSize; i++) {
                            for (let j = 0; j < gridSize; j++) {
                                alphas.push((i + 0.5) / gridSize);
                                if (alphas.length >= numSamples) break;
                            }
                            if (alphas.length >= numSamples) break;
                        }
                        break;
                        
                    case 'adaptive':
                        // Start with major arcs, then adaptively refine
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                    // Add nearby points for adaptive refinement
                                    if (precision === 'high' || precision === 'ultra') {
                                        const delta = precision === 'ultra' ? 0.001 : 0.01;
                                        alphas.push((p / q) + delta);
                                        alphas.push((p / q) - delta);
                                    }
                                }
                            }
                        }
                        // Add adaptive grid points
                        for (let i = 0; i < numSamples; i++) {
                            alphas.push(Math.random());
                        }
                        break;
                        
                    case 'comprehensive':
                        // Combine all methods for thorough testing
                        // Major arcs
                        for (let q = 1; q <= maxDenom; q++) {
                            for (let p = 0; p < q; p++) {
                                if (this.gcd(p, q) === 1) {
                                    alphas.push(p / q);
                                }
                            }
                        }
                        // Uniform grid
                        for (let i = 0; i < gridSize; i++) {
                            alphas.push(i / gridSize);
                        }
                        // Random sampling
                        for (let i = 0; i < Math.floor(numSamples / 2); i++) {
                            alphas.push(Math.random());
                        }
                        break;
                }
                
                return [...new Set(alphas.map(a => Math.abs(a % 1)))]; // Remove duplicates and normalize
            }

            gcd(a, b) {
                while (b !== 0) {
                    [a, b] = [b, a % b];
                }
                return a;
            }

            formatAlpha(alpha) {
                // Try to express as a simple fraction
                const tolerance = 1e-10;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            return num + '/' + denom;
                        }
                    }
                }
                return alpha.toFixed(8);
            }

            determineAlphaType(alpha) {
                const tolerance = 1e-10;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            if (denom <= 12) return 'Major Arc';
                            return 'Rational';
                        }
                    }
                }
                return 'Irrational';
            }

            async runEnhancedVerification(maxN, testMode, numSamples, maxDenom, gridSize, precision, options) {
                return new Promise((resolve) => {
                    const startTime = performance.now();
                    
                    // Update UI
                    document.getElementById('progressContainer').style.display = 'block';
                    document.getElementById('results').style.display = 'none';
                    document.getElementById('visualizationGrid').style.display = 'none';
                    
                    const updateProgress = (message, progress) => {
                        document.getElementById('statusText').textContent = message;
                        document.getElementById('progressFill').style.width = progress + '%';
                    };
                    
                    // Initialize variables at the top level
                    let maxSum = 0;
                    let bestAlpha = 0;
                    const results = [];
                    const convergencePoints = [];
                    let phaseData = []; // Declare at function scope
                    
                    // Store phaseData in instance for later access
                    this.phaseData = [];
                    
                    setTimeout(() => {
                        updateProgress('Computing enhanced Möbius function...', 5);
                        
                        setTimeout(() => {
                            // Step 1: Compute Möbius function
                            this.computeMobius(maxN);
                            updateProgress('Generating α test values with ' + precision + ' precision...', 15);
                            
                            setTimeout(() => {
                                // Step 2: Generate α values
                                const alphas = this.generateAlphaValues(testMode, numSamples, maxDenom, gridSize, precision);
                                updateProgress('Testing ' + alphas.length + ' α values with enhanced analysis...', 25);
                                
                                setTimeout(() => {
                                    // Step 3: Test exponential sums with enhanced tracking
                                    const sqrtN = Math.sqrt(maxN);
                                    
                                    alphas.forEach((alpha, i) => {
                                        const trackPhase = options.enablePhaseAnalysis && i < 10;
                                        const sumResult = this.computeExponentialSum(maxN, alpha, trackPhase);
                                        
                                        results.push({
                                            alpha: alpha,
                                            sum: sumResult.magnitude,
                                            phase: sumResult.phase,
                                            real: sumResult.real,
                                            imaginary: sumResult.imaginary,
                                            type: this.determineAlphaType(alpha)
                                        });
                                        
                                        if (trackPhase && sumResult.phases && sumResult.phases.length > 0) {
                                            phaseData = phaseData.concat(sumResult.phases);
                                            this.phaseData = this.phaseData.concat(sumResult.phases);
                                        }
                                        
                                        if (sumResult.magnitude > maxSum) {
                                            maxSum = sumResult.magnitude;
                                            bestAlpha = alpha;
                                        }
                                        
                                        // Track convergence
                                        if (i % Math.max(1, Math.floor(alphas.length / 20)) === 0) {
                                            convergencePoints.push({
                                                iteration: i,
                                                maxSum: maxSum,
                                                currentSum: sumResult.magnitude
                                            });
                                        }
                                        
                                        if (options.realTimeUpdates && i % Math.max(1, Math.floor(alphas.length / 20)) === 0) {
                                            const progress = 25 + 65 * (i / alphas.length);
                                            updateProgress('Testing α values... ' + (i + 1) + '/' + alphas.length + ' (max: ' + maxSum.toFixed(3) + ')', progress);
                                        }
                                    });
                                    
                                    const endTime = performance.now();
                                    const computeTime = endTime - startTime;
                                    const ratio = maxSum / sqrtN;
                                    
                                    updateProgress('Generating advanced visualizations...', 95);
                                    
                                    setTimeout(() => {
                                        updateProgress('Enhanced computation complete!', 100);
                                        
                                        resolve({
                                            maxN,
                                            sqrtN,
                                            maxSum,
                                            ratio,
                                            bestAlpha,
                                            computeTime,
                                            results: results.sort((a, b) => b.sum - a.sum),
                                            phaseData: phaseData,
                                            convergenceData: convergencePoints,
                                            statistics: this.calculateStatistics(results),
                                            options
                                        });
                                    }, 200);
                                }, 100);
                            }, 100);
                        }, 100);
                    }, 100);
                });
            }

            calculateStatistics(results) {
                const sums = results.map(r => r.sum);
                const phases = results.map(r => r.phase);
                
                return {
                    mean: sums.reduce((a, b) => a + b, 0) / sums.length,
                    median: this.median(sums),
                    stdDev: this.standardDeviation(sums),
                    variance: this.variance(sums),
                    skewness: this.skewness(sums),
                    kurtosis: this.kurtosis(sums),
                    min: Math.min(...sums),
                    max: Math.max(...sums),
                    q1: this.percentile(sums, 25),
                    q3: this.percentile(sums, 75),
                    majorArcCount: results.filter(r => r.type === 'Major Arc').length,
                    rationalCount: results.filter(r => r.type === 'Rational').length,
                    irrationalCount: results.filter(r => r.type === 'Irrational').length
                };
            }

            median(arr) {
                const sorted = [...arr].sort((a, b) => a - b);
                const mid = Math.floor(sorted.length / 2);
                return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
            }

            standardDeviation(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
                return Math.sqrt(variance);
            }

            variance(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                return arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length;
            }

            skewness(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = this.standardDeviation(arr);
                const n = arr.length;
                return arr.reduce((sum, val) => sum + Math.pow((val - mean) / std, 3), 0) / n;
            }

            kurtosis(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const std = this.standardDeviation(arr);
                const n = arr.length;
                return arr.reduce((sum, val) => sum + Math.pow((val - mean) / std, 4), 0) / n - 3;
            }

            percentile(arr, p) {
                const sorted = [...arr].sort((a, b) => a - b);
                const index = (p / 100) * (sorted.length - 1);
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                return sorted[lower] + (sorted[upper] - sorted[lower]) * (index - lower);
            }

            displayEnhancedResults(results) {
                const {maxN, sqrtN, maxSum, ratio, bestAlpha, computeTime, results: topResults, statistics, options} = results;
                
                // Basic metrics
                document.getElementById('resultN').textContent = maxN.toLocaleString();
                document.getElementById('resultSqrtN').textContent = sqrtN.toFixed(2);
                document.getElementById('resultMaxSum').textContent = maxSum.toFixed(6);
                document.getElementById('resultRatio').textContent = ratio.toFixed(8);
                document.getElementById('resultBestAlpha').textContent = this.formatAlpha(bestAlpha);
                document.getElementById('computeTime').textContent = (computeTime/1000).toFixed(3) + 's';
                document.getElementById('opsPerSec').textContent = (maxN / (computeTime/1000)).toExponential(3);
                document.getElementById('memoryEff').textContent = (maxN / (1024 * 1024)).toFixed(2) + 'MB';
                
                // Enhanced RH status with cosmic themes
                let rhStatus, rhClass;
                if (ratio < 0.2) {
                    rhStatus = ' COSMIC EXCELLENCE - Extraordinary RH Support (ratio < 0.2)';
                    rhClass = 'status-cosmic';
                } else if (ratio < 0.4) {
                    rhStatus = ' LEGENDARY - Outstanding RH Support (ratio < 0.4)';
                    rhClass = 'status-legendary';
                } else if (ratio < 0.8) {
                    rhStatus = ' MYTHICAL - Excellent RH Support (ratio < 0.8)';
                    rhClass = 'status-mythical';
                } else if (ratio < 1.5) {
                    rhStatus = ' EXCELLENT - Good RH Support (ratio < 1.5)';
                    rhClass = 'status-excellent';
                } else if (ratio < 3.0) {
                    rhStatus = ' GOOD - Acceptable RH Support (ratio < 3.0)';
                    rhClass = 'status-good';
                } else {
                    rhStatus = ' HIGH - Needs Investigation (ratio ≥ 3.0)';
                    rhClass = 'status-high';
                }
                
                const statusElement = document.getElementById('cosmicStatus');
                statusElement.textContent = rhStatus;
                statusElement.className = 'cosmic-status ' + rhClass;
                statusElement.style.display = 'block';
                
                // Statistical summary
                if (options.showStatistics && statistics) {
                    this.displayStatistics(statistics);
                    document.getElementById('statisticalSummary').style.display = 'block';
                }
                
                // Show detailed results if enabled
                if (options.showDetails) {
                    this.displayDetailedResults(topResults, maxN, sqrtN, ratio, statistics);
                    document.getElementById('detailedResults').style.display = 'block';
                } else {
                    document.getElementById('detailedResults').style.display = 'none';
                }
                
                document.getElementById('results').style.display = 'block';
                document.getElementById('progressContainer').style.display = 'none';
                
                // Store results for export
                this.currentTest = results;
                
                // Generate visualizations
                if (options.generateHeatmap || options.showDetails) {
                    this.generateEnhancedVisualizations(results);
                }
                
                // Debug: Log phase data availability
                console.log('Phase data available:', results.phaseData ? results.phaseData.length : 0, 'points');
                if (results.phaseData && results.phaseData.length > 0) {
                    console.log('First phase point:', results.phaseData[0]);
                }
            }

            displayStatistics(stats) {
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-value">${stats.mean.toFixed(4)}</div>
                        <div class="stat-label">Mean |S(N,α)|</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.median.toFixed(4)}</div>
                        <div class="stat-label">Median |S(N,α)|</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.stdDev.toFixed(4)}</div>
                        <div class="stat-label">Standard Deviation</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.skewness.toFixed(3)}</div>
                        <div class="stat-label">Skewness</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.majorArcCount}</div>
                        <div class="stat-label">Major Arc Results</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${(stats.majorArcCount / (stats.majorArcCount + stats.rationalCount + stats.irrationalCount) * 100).toFixed(1)}%</div>
                        <div class="stat-label">Major Arc Percentage</div>
                    </div>
                `;
            }

            displayDetailedResults(topResults, maxN, sqrtN, ratio, statistics) {
                // Top results table
                const tbody = document.getElementById('topResultsBody');
                tbody.innerHTML = '';
                
                topResults.slice(0, 15).forEach((result, i) => {
                    const resultRatio = result.sum / sqrtN;
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${i + 1}</td>
                        <td>${this.formatAlpha(result.alpha)}</td>
                        <td>${result.sum.toFixed(6)}</td>
                        <td>${resultRatio.toFixed(6)}</td>
                        <td>${result.type}</td>
                    `;
                    tbody.appendChild(row);
                });
                
                // Mathematical insights
                const insights = this.generateEnhancedInsights(topResults, maxN, sqrtN, ratio, statistics);
                document.getElementById('insightsContent').innerHTML = insights;
                
                // Distribution analysis
                if (statistics) {
                    document.getElementById('distributionAnalysis').innerHTML = this.generateDistributionAnalysis(statistics, topResults);
                }
                
                // Phase analysis
                if (results.phaseData && results.phaseData.length > 0) {
                    document.getElementById('phaseAnalysis').innerHTML = this.generatePhaseAnalysis(results.phaseData);
                }
            }

            generateEnhancedInsights(topResults, maxN, sqrtN, ratio, statistics) {
                let insights = '';
                
                // Major arc dominance analysis
                const majorArcResults = topResults.filter(r => r.type === 'Major Arc').slice(0, 10);
                if (majorArcResults.length > 0) {
                    insights += `<p><strong>Major Arc Dominance:</strong> ${majorArcResults.length} of the top 10 exponential sums occur at major arc α values, confirming classical analytic number theory predictions.</p>`;
                }
                
                // Statistical significance
                if (statistics) {
                    insights += `<p><strong>Statistical Profile:</strong> Mean ratio: ${(statistics.mean / sqrtN).toFixed(4)}, Standard deviation: ${(statistics.stdDev / sqrtN).toFixed(4)}, Skewness: ${statistics.skewness.toFixed(3)}. `;
                    
                    if (Math.abs(statistics.skewness) < 0.5) {
                        insights += 'Distribution is approximately symmetric.</p>';
                    } else if (statistics.skewness > 0.5) {
                        insights += 'Distribution shows positive skew (tail towards larger values).</p>';
                    } else {
                        insights += 'Distribution shows negative skew (tail towards smaller values).</p>';
                    }
                }
                
                // RH interpretation with enhanced analysis
                if (ratio < 0.5) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} provides exceptionally strong computational evidence supporting the Riemann Hypothesis for N = ${maxN.toLocaleString()}. This level of bound satisfaction is remarkable.</p>`;
                } else if (ratio < 1.0) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} is well within theoretical bounds, providing solid evidence supporting RH predictions.</p>`;
                } else if (ratio < 2.0) {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} remains within reasonable bounds for RH, though elevated. This is still consistent with the O(√N) prediction.</p>`;
                } else {
                    insights += `<p><strong>RH Interpretation:</strong> The ratio ${ratio.toFixed(6)} is significantly elevated. While potentially still consistent with RH (which allows some flexibility), this warrants deeper investigation.</p>`;
                }
                
                // Computational achievement
                insights += `<p><strong>Computational Achievement:</strong> Successfully verified RH predictions for ${maxN.toLocaleString()} integers using advanced browser-based algorithms, demonstrating modern JavaScript's capability for serious mathematical research.</p>`;
                
                // Research directions
                insights += `<p><strong>Future Research:</strong> Consider investigating the specific α values producing maximal sums, exploring larger N values, or applying these techniques to related L-functions and Dirichlet series.</p>`;
                
                return insights;
            }

            generateDistributionAnalysis(statistics, results) {
                let analysis = `
                    <div class="statistics-grid">
                        <div class="stat-card">
                            <div class="stat-value">${statistics.q1.toFixed(4)}</div>
                            <div class="stat-label">First Quartile (Q1)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${statistics.q3.toFixed(4)}</div>
                            <div class="stat-label">Third Quartile (Q3)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${(statistics.q3 - statistics.q1).toFixed(4)}</div>
                            <div class="stat-label">Interquartile Range</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${statistics.kurtosis.toFixed(3)}</div>
                            <div class="stat-label">Kurtosis</div>
                        </div>
                    </div>
                `;
                
                // Distribution shape analysis
                analysis += '<h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">Distribution Shape Analysis</h5>';
                if (statistics.kurtosis > 0) {
                    analysis += '<p>The distribution exhibits positive kurtosis (heavy tails), indicating more extreme values than a normal distribution would predict.</p>';
                } else {
                    analysis += '<p>The distribution exhibits negative kurtosis (light tails), indicating fewer extreme values than expected.</p>';
                }
                
                // Type distribution
                analysis += '<h5 style="color: #4ecdc4; margin: 20px 0 10px 0;">α Value Type Distribution</h5>';
                analysis += `<p>Major Arcs: ${statistics.majorArcCount}, Rational: ${statistics.rationalCount}, Irrational: ${statistics.irrationalCount}</p>`;
                
                return analysis;
            }

            generatePhaseAnalysis(phaseData) {
                if (!phaseData || phaseData.length === 0) {
                    return '<p>Phase analysis data not available for this test.</p>';
                }
                
                let analysis = '<h5 style="color: #4ecdc4; margin-bottom: 10px;">Phase Behavior Analysis</h5>';
                
                // Calculate phase statistics
                const phases = phaseData.map(p => p.phase);
                const meanPhase = phases.reduce((a, b) => a + b, 0) / phases.length;
                const phaseRange = Math.max(...phases) - Math.min(...phases);
                
                analysis += `<p><strong>Mean Phase:</strong> ${meanPhase.toFixed(4)} radians (${(meanPhase * 180 / Math.PI).toFixed(2)}°)</p>`;
                analysis += `<p><strong>Phase Range:</strong> ${phaseRange.toFixed(4)} radians (${(phaseRange * 180 / Math.PI).toFixed(2)}°)</p>`;
                
                // Phase distribution
                const phaseDistribution = this.analyzePhaseDistribution(phases);
                analysis += `<p><strong>Phase Distribution:</strong> ${phaseDistribution}</p>`;
                
                return analysis;
            }

            analyzePhaseDistribution(phases) {
                const bins = 8;
                const binSize = (2 * Math.PI) / bins;
                const counts = new Array(bins).fill(0);
                
                phases.forEach(phase => {
                    const normalizedPhase = ((phase % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
                    const bin = Math.min(Math.floor(normalizedPhase / binSize), bins - 1);
                    counts[bin]++;
                });
                
                const maxCount = Math.max(...counts);
                const minCount = Math.min(...counts);
                
                if (maxCount - minCount < phases.length * 0.1) {
                    return 'Approximately uniform distribution across phase space';
                } else {
                    return 'Non-uniform phase distribution with clustering';
                }
            }

            generateEnhancedVisualizations(results) {
                const {results: topResults, convergenceData, phaseData, options} = results;
                
                // Main distribution chart
                this.drawDistributionChart(topResults, results.sqrtN);
                
                // Heatmap if enabled
                if (options.generateHeatmap) {
                    this.drawComplexityHeatmap(topResults);
                }
                
                // Phase chart if data available
                if (phaseData && phaseData.length > 0) {
                    this.drawPhaseChart(phaseData);
                }
                
                // Convergence analysis
                if (convergenceData && convergenceData.length > 0) {
                    this.drawConvergenceChart(convergenceData);
                }
                
                // Scatter plot
                this.drawScatterPlot(topResults, results.sqrtN);
                
                // Histogram
                this.drawHistogram(topResults);
                
                document.getElementById('visualizationGrid').style.display = 'grid';
            }

            drawDistributionChart(results, sqrtN) {
                const canvas = document.getElementById('sumChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxSum = Math.max(...results.map(r => r.sum));
                const displayResults = results.slice(0, 50);
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw √N reference line
                const sqrtNY = canvas.height - padding - (sqrtN / maxSum) * height;
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(padding, sqrtNY);
                ctx.lineTo(canvas.width - padding, sqrtNY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw data points with color coding
                displayResults.forEach((result, i) => {
                    const x = padding + (i / (displayResults.length - 1)) * width;
                    const y = canvas.height - padding - (result.sum / maxSum) * height;
                    
                    // Color by type
                    if (result.type === 'Major Arc') {
                        ctx.fillStyle = '#ff6b6b';
                    } else if (result.type === 'Rational') {
                        ctx.fillStyle = '#feca57';
                    } else {
                        ctx.fillStyle = '#4ecdc4';
                    }
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('Top α values (ranked)', canvas.width / 2 - 50, canvas.height - 10);
                ctx.fillText('√N = ' + sqrtN.toFixed(1), canvas.width - 80, sqrtNY - 5);
            }

            drawComplexityHeatmap(results) {
                const canvas = document.getElementById('heatmapChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const gridSize = 32;
                const cellWidth = canvas.width / gridSize;
                const cellHeight = canvas.height / gridSize;
                
                // Create complexity grid
                const complexityGrid = new Array(gridSize).fill(null).map(() => new Array(gridSize).fill(0));
                
                results.slice(0, gridSize * gridSize).forEach((result, i) => {
                    const x = i % gridSize;
                    const y = Math.floor(i / gridSize);
                    complexityGrid[y][x] = result.sum;
                });
                
                const maxComplexity = Math.max(...results.map(r => r.sum));
                
                // Draw heatmap
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const intensity = complexityGrid[y][x] / maxComplexity;
                        const hue = (1 - intensity) * 180; // Blue to red
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                    }
                }
            }

            drawPhaseChart(phaseData) {
                const canvas = document.getElementById('phaseChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 30;
                
                // Draw unit circle
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Draw axes
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(centerX - radius, centerY);
                ctx.lineTo(centerX + radius, centerY);
                ctx.moveTo(centerX, centerY - radius);
                ctx.lineTo(centerX, centerY + radius);
                ctx.stroke();
                
                // If no phase data, show message and simulate some points
                if (!phaseData || phaseData.length === 0) {
                    ctx.fillStyle = '#a0a0a0';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Enable Phase Analysis to see data', centerX, centerY + 60);
                    
                    // Draw some example phase points in a circle pattern
                    ctx.fillStyle = '#666';
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * 2 * Math.PI;
                        const x = centerX + radius * 0.7 * Math.cos(angle);
                        const y = centerY + radius * 0.7 * Math.sin(angle);
                        
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    return;
                }
                
                // Plot actual phase points with color coding by magnitude
                const maxMagnitude = Math.max(...phaseData.map(p => p.magnitude));
                
                phaseData.forEach(point => {
                    const x = centerX + radius * 0.8 * Math.cos(point.phase);
                    const y = centerY + radius * 0.8 * Math.sin(point.phase);
                    
                    // Color based on magnitude
                    const intensity = point.magnitude / maxMagnitude;
                    const hue = intensity * 60; // Red to yellow
                    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Reset text alignment
                ctx.textAlign = 'left';
            }

            drawConvergenceChart(convergenceData) {
                const canvas = document.getElementById('convergenceChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxSum = Math.max(...convergenceData.map(d => d.maxSum));
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw convergence line
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                convergenceData.forEach((point, i) => {
                    const x = padding + (i / (convergenceData.length - 1)) * width;
                    const y = canvas.height - padding - (point.maxSum / maxSum) * height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('Iteration', canvas.width / 2 - 20, canvas.height - 10);
            }

            drawScatterPlot(results, sqrtN) {
                const canvas = document.getElementById('scatterChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                const maxRatio = Math.max(...results.map(r => r.sum / sqrtN));
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Draw y = 1 reference line
                const refY = canvas.height - padding - (1 / maxRatio) * height;
                ctx.strokeStyle = '#ff6b6b';
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(padding, refY);
                ctx.lineTo(canvas.width - padding, refY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Plot points
                results.slice(0, 100).forEach(result => {
                    const x = padding + (result.alpha * width);
                    const ratio = result.sum / sqrtN;
                    const y = canvas.height - padding - (ratio / maxRatio) * height;
                    
                    ctx.fillStyle = result.type === 'Major Arc' ? '#ff6b6b' : '#4ecdc4';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, 2 * Math.PI);
                    ctx.fill();
                });
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('α value', canvas.width / 2 - 20, canvas.height - 10);
                ctx.fillText('Ratio = 1', canvas.width - 80, refY - 5);
            }

            drawHistogram(results) {
                const canvas = document.getElementById('histogramChart');
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const padding = 40;
                const width = canvas.width - 2 * padding;
                const height = canvas.height - 2 * padding;
                
                // Create histogram bins
                const bins = 20;
                const sums = results.map(r => r.sum);
                const minSum = Math.min(...sums);
                const maxSum = Math.max(...sums);
                const binWidth = (maxSum - minSum) / bins;
                const binCounts = new Array(bins).fill(0);
                
                sums.forEach(sum => {
                    const binIndex = Math.min(Math.floor((sum - minSum) / binWidth), bins - 1);
                    binCounts[binIndex]++;
                });
                
                const maxCount = Math.max(...binCounts);
                const barWidth = width / bins;
                
                // Draw bars
                binCounts.forEach((count, i) => {
                    const barHeight = (count / maxCount) * height;
                    const x = padding + i * barWidth;
                    const y = canvas.height - padding - barHeight;
                    
                    ctx.fillStyle = '#4ecdc4';
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                });
                
                // Draw axes
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, canvas.height - padding);
                ctx.lineTo(canvas.width - padding, canvas.height - padding);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#e0e0e0';
                ctx.font = '12px Arial';
                ctx.fillText('|S(N,α)| value', canvas.width / 2 - 30, canvas.height - 10);
            }

            isSimpleRational(alpha) {
                const tolerance = 1e-8;
                for (let denom = 1; denom <= 20; denom++) {
                    for (let num = 0; num < denom; num++) {
                        if (Math.abs(alpha - num/denom) < tolerance && this.gcd(num, denom) === 1) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        // Initialize the enhanced application
        const enhancedTester = new EnhancedRiemannHypothesisTester();

        // Global functions for UI interactions
        function setPreset(value) {
            document.getElementById('customN').value = value;
            updatePerformanceIndicator(value);
            
            // Auto-optimize parameters for large N to prevent memory issues
            if (value >= 50000000) {
                document.getElementById('numSamples').value = '50';
                document.getElementById('maxDenom').value = '8';
                document.getElementById('gridSize').value = '32';
            } else if (value >= 10000000) {
                document.getElementById('numSamples').value = '75';
                document.getElementById('maxDenom').value = '10';
                document.getElementById('gridSize').value = '48';
            } else if (value >= 1000000) {
                document.getElementById('numSamples').value = '100';
                document.getElementById('maxDenom').value = '12';
                document.getElementById('gridSize').value = '64';
            } else {
                document.getElementById('numSamples').value = '150';
                document.getElementById('maxDenom').value = '15';
                document.getElementById('gridSize').value = '64';
            }
        }

        function updatePerformanceIndicator(n) {
            const indicator = document.getElementById('performanceIndicator');
            
            if (n < 100000) {
                indicator.className = 'performance-indicator perf-excellent';
                indicator.innerHTML = '⚡ Excellent performance expected (< 1 second)';
            } else if (n < 1000000) {
                indicator.className = 'performance-indicator perf-good';
                indicator.innerHTML = '🟢 Good performance expected (1-3 seconds)';
            } else if (n < 10000000) {
                indicator.className = 'performance-indicator perf-warning';
                indicator.innerHTML = '🟡 Moderate performance expected (5-15 seconds)';
            } else {
                indicator.className = 'performance-indicator perf-danger';
                indicator.innerHTML = '🔴 Slower performance expected (15+ seconds)';
            }
        }

        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab and activate button
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function exportResults(format) {
            if (!enhancedTester.currentTest) {
                alert('No test results to export. Please run a test first.');
                return;
            }
            
            const results = enhancedTester.currentTest;
            let content = '';
            let filename = '';
            let mimeType = '';
            
            switch (format) {
                case 'csv':
                    content = 'Alpha,Sum,Ratio,Type,Phase,Real,Imaginary\n';
                    results.results.forEach(r => {
                        content += `${r.alpha},${r.sum},${r.sum/results.sqrtN},${r.type},${r.phase},${r.real},${r.imaginary}\n`;
                    });
                    filename = `riemann_test_${results.maxN}.csv`;
                    mimeType = 'text/csv';
                    break;
                    
                case 'json':
                    content = JSON.stringify(results, null, 2);
                    filename = `riemann_test_${results.maxN}.json`;
                    mimeType = 'application/json';
                    break;
                    
                case 'txt':
                    content = `Enhanced Riemann Hypothesis Test Report\n`;
                    content += `==========================================\n\n`;
                    content += `Test Parameters:\n`;
                    content += `- Maximum N: ${results.maxN.toLocaleString()}\n`;
                    content += `- √N bound: ${results.sqrtN.toFixed(6)}\n`;
                    content += `- Maximum |S(N,α)|: ${results.maxSum.toFixed(6)}\n`;
                    content += `- Ratio: ${results.ratio.toFixed(8)}\n`;
                    content += `- Best α: ${enhancedTester.formatAlpha(results.bestAlpha)}\n`;
                    content += `- Computation time: ${(results.computeTime/1000).toFixed(3)}s\n\n`;
                    
                    content += `Statistical Summary:\n`;
                    if (results.statistics) {
                        content += `- Mean: ${results.statistics.mean.toFixed(6)}\n`;
                        content += `- Standard deviation: ${results.statistics.stdDev.toFixed(6)}\n`;
                        content += `- Skewness: ${results.statistics.skewness.toFixed(4)}\n`;
                        content += `- Major arc results: ${results.statistics.majorArcCount}\n`;
                    }
                    
                    content += `\nTop 10 Results:\n`;
                    results.results.slice(0, 10).forEach((r, i) => {
                        content += `${i+1}. α=${enhancedTester.formatAlpha(r.alpha)}, |S|=${r.sum.toFixed(6)}, ratio=${(r.sum/results.sqrtN).toFixed(6)}, type=${r.type}\n`;
                    });
                    
                    filename = `riemann_test_report_${results.maxN}.txt`;
                    mimeType = 'text/plain';
                    break;
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportVisualization() {
            const canvas = document.getElementById('sumChart');
            const url = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = url;
            a.download = 'riemann_visualization.png';
            a.click();
        }

        // Event listeners
        document.getElementById('startTest').addEventListener('click', async function() {
            if (enhancedTester.isComputing) return;
            
            enhancedTester.isComputing = true;
            const button = document.getElementById('startTest');
            button.disabled = true;
            button.textContent = 'Computing...';
            document.body.classList.add('computing');
            
            // Get parameters
            const maxN = parseInt(document.getElementById('customN').value);
            const testMode = document.getElementById('testMode').value;
            const numSamples = parseInt(document.getElementById('numSamples').value);
            const maxDenom = parseInt(document.getElementById('maxDenom').value);
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const precision = document.getElementById('precisionLevel').value;
            
            const options = {
                showDetails: document.getElementById('showDetails').checked,
                generateHeatmap: document.getElementById('generateHeatmap').checked,
                showStatistics: document.getElementById('showStatistics').checked,
                realTimeUpdates: document.getElementById('realTimeUpdates').checked,
                enablePhaseAnalysis: document.getElementById('enablePhaseAnalysis').checked,
                enableDistributionAnalysis: document.getElementById('enableDistributionAnalysis').checked,
                enableFrequencyAnalysis: document.getElementById('enableFrequencyAnalysis').checked
            };
            
            // Validate input
            if (isNaN(maxN) || maxN < 1 || maxN > 100000000) {
                alert('Please enter a valid number between 1 and 100,000,000');
                enhancedTester.isComputing = false;
                button.disabled = false;
                button.textContent = '🚀 Launch Enhanced Cosmic Test';
                document.body.classList.remove('computing');
                return;
            }
            
            try {
                const results = await enhancedTester.runEnhancedVerification(maxN, testMode, numSamples, maxDenom, gridSize, precision, options);
                enhancedTester.displayEnhancedResults(results);
            } catch (error) {
                console.error('Enhanced computation error:', error);
                alert('An error occurred during computation. Please try again with smaller parameters.');
            }
            
            enhancedTester.isComputing = false;
            button.disabled = false;
            button.textContent = '🚀 Launch Enhanced Cosmic Test';
            document.body.classList.remove('computing');
        });

        // Input validation and performance updates
        document.getElementById('customN').addEventListener('input', function() {
            const value = parseInt(this.value);
            
            if (value > 100000000) {
                this.value = 100000000;
            } else if (value < 1) {
                this.value = 1;
            }
            
            updatePerformanceIndicator(parseInt(this.value));
            
            // Auto-optimize for very large values
            if (value > 25000000) {
                setPreset(value);
            }
        });

        // Initialize with default performance indicator
        updatePerformanceIndicator(1000000);
    </script>

<title>A Fully Explicit Explanation of a Finite-cutoff Identity for the Twin-prime Sieve Factors</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                packages: {'[+]': ['ams', 'mathtools']}
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    // Calculate initial example when MathJax is ready
                    setTimeout(calculateIdentity, 1000);
                }
            }
        };
    </script>
    <style>
        body {
            font-family: 'Times', serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: #fefefe;
            color: #333;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            border-bottom: 2px solid #333;
            padding-bottom: 30px;
        }
        
        h1 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #1a1a1a;
        }
        
        .author {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .date {
            font-size: 16px;
            color: #666;
        }
        
        .interactive-section {
            background-color: #f0f8ff;
            border: 2px solid #4682b4;
            border-radius: 10px;
            padding: 25px;
            margin: 30px 0;
        }
        
        .calculator-box {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            margin-top: 15px;
        }
        
        .calculator-box label {
            font-weight: bold;
            display: block;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .calculator-box input {
            padding: 8px 12px;
            border: 2px solid #bdc3c7;
            border-radius: 4px;
            font-size: 16px;
            margin-right: 10px;
            width: 100px;
        }
        
        .calculator-box button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .calculator-box button:hover {
            background-color: #2980b9;
        }
        
        .results-display {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            min-height: 50px;
        }
        
        .calculation-step {
            background-color: white;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .calculation-step h4 {
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .verification {
            background-color: #f8f9fa;
            border: 2px solid #28a745;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .verification h4 {
            color: #155724;
            margin-top: 0;
        }
        
        .per-prime-work {
            background-color: #e8f5e8;
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .prime-calculation {
            background-color: white;
            border: 1px solid #28a745;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .prime-calculation h5 {
            color: #155724;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: bold;
            border-bottom: 1px solid #c3e6cb;
            padding-bottom: 5px;
        }
        
        .abstract {
            background-color: #f9f9f9;
            border-left: 4px solid #2c3e50;
            padding: 20px;
            margin: 30px 0;
            font-style: italic;
        }
        
        .abstract h2 {
            margin-top: 0;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #2c3e50;
        }
        
        h2 {
            font-size: 20px;
            margin-top: 40px;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        
        h3 {
            font-size: 18px;
            margin-top: 30px;
            margin-bottom: 15px;
            color: #34495e;
        }
        
        .theorem {
            background-color: #e8f4f8;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            margin: 25px 0;
        }
        
        .theorem-title {
            font-weight: bold;
            color: #2980b9;
            margin-bottom: 15px;
        }
        
        .boxed-formula {
            background-color: #fff;
            border: 3px solid #e74c3c;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .proof-section {
            background-color: #f8f9fa;
            border-left: 4px solid #28a745;
            padding: 20px;
            margin: 25px 0;
        }
        
        .example-section {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .example-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 15px;
        }
        
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        .math-display {
            margin: 20px 0;
            text-align: center;
        }
        
        .interpretation {
            background-color: #f0f8ff;
            border: 1px solid #87ceeb;
            border-radius: 5px;
            padding: 20px;
            margin: 25px 0;
        }
        
        .paragraph-title {
            font-weight: bold;
            color: #4682b4;
            margin-bottom: 10px;
        }
        
        .qed {
            text-align: right;
            font-weight: bold;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>A Fully Explicit Explanation of a Finite-cutoff Identity for the Twin-prime Sieve Factors</h1>
        <div class="author">Wessen Getachew</div>
        <div class="date">September 16, 2025</div>
    </div>

    <div class="interactive-section">
        <h2>Interactive Calculator</h2>
        <div class="calculator-box">
            <label for="pmax-input">Enter p_max (prime ≥ 3):</label>
            <input type="number" id="pmax-input" value="7" min="3" step="1">
            <button onclick="calculateIdentity()">Calculate Identity</button>
            
            <div id="results" class="results-display">
                <!-- Results will appear here -->
            </div>
        </div>
    </div>

    <div class="abstract">
        <h2>Abstract</h2>
        <p>This note gives a fully explicit statement, proof, and numerical examples of the finite-cutoff identity</p>
        <div class="math-display">
            \[
            \prod_{\substack{p\text{ prime}\\3\le p\le p_{\max}}}\frac{(p-1)(p-2)}{p^{2}}
            =
            \left(\prod_{\substack{p\text{ prime}\\3\le p\le p_{\max}}}\left(1-\frac{1}{(p-1)^{2}}\right)\right)
            \left(\prod_{\substack{p\text{ prime}\\3\le p\le p_{\max}}}\left(1-\frac{1}{p}\right)\right)^{3},
            \]
        </div>
        <p>with every symbol defined and with explicit arithmetic checks for small cutoffs. The document also discusses the meaning and implications of this identity for the special prime gap of size two (twin primes).</p>
    </div>

    <h2>Notation and conventions</h2>
    <ul>
        <li>Throughout this note, \(p\) denotes a <em>prime number</em>. We use \(p_{\max}\) to denote a fixed finite cutoff prime, and we assume \(p_{\max}\ge 3\).</li>
        <li>The phrase "product over primes \(3\le p\le p_{\max}\)" means the finite product taken over every prime \(p\) satisfying \(3\le p\le p_{\max}\); that is, \(p\in\{3,5,7,\dots,p_{\max}\}\).</li>
        <li>We write the ordinary multiplicative symbol \(\prod\) with explicit index conditions whenever clarity is needed.</li>
        <li>We define the following three functions of the cutoff \(p_{\max}\) (these are <em>finite</em> products):
            <div class="math-display">
                \begin{align}
                N(p_{\max}) &:= \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}} \frac{(p-1)(p-2)}{p^{2}}, \\[6pt]
                C_{2}(p_{\max}) &:= \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}}\left(1-\frac{1}{(p-1)^{2}}\right), \\[6pt]
                M_{\neq 2}(p_{\max}) &:= \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}}\left(1-\frac{1}{p}\right).
                \end{align}
            </div>
        </li>
        <li>Note explicitly: the product index \(\{3\le p\le p_{\max}\}\) starts at \(p=3\). We <em>exclude</em> \(p=2\) because the factor \(\frac{(2-2)}{2^{2}}=0\) would zero out the entire left-hand product and make the identity meaningless.</li>
    </ul>

    <h2>Exact finite identity (statement)</h2>
    <div class="theorem">
        <div class="theorem-title">Theorem (Finite prime-by-prime factorization)</div>
        <p>For every integer \(p_{\max}\ge 3\), the following identity holds exactly:</p>
        <div class="boxed-formula">
            \[
            \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}} \frac{(p-1)(p-2)}{p^{2}}
            \;=\;
            \left( \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}} \!\left(1-\frac{1}{(p-1)^{2}}\right) \right)
            \cdot
            \left( \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}} \!\left(1-\frac{1}{p}\right) \right)^{3}
            \]
        </div>
        <p>In short notation, \(N(p_{\max}) = C_{2}(p_{\max})\,[M_{\neq 2}(p_{\max})]^{3}\).</p>
    </div>

    <h2>Proof (termwise algebraic identity)</h2>
    <div class="proof-section">
        <p>We prove the theorem by showing the identity holds for each single prime factor \(p\ge 3\), and then taking the product over all such primes up to the cutoff.</p>

        <p>Fix a prime \(p\) with \(p\ge 3\). Compute two elementary algebraic expressions.</p>

        <p>First,</p>
        <div class="math-display">
            \[
            1-\frac{1}{(p-1)^{2}}
            = \frac{(p-1)^{2}-1}{(p-1)^{2}}
            = \frac{p^{2}-2p}{(p-1)^{2}}
            = \frac{p(p-2)}{(p-1)^{2}}.
            \]
        </div>

        <p>Second,</p>
        <div class="math-display">
            \[
            1-\frac{1}{p}=\frac{p-1}{p}.
            \]
        </div>
        <p>Cubing the second expression gives</p>
        <div class="math-display">
            \[
            \left(1-\frac{1}{p}\right)^{3}=\frac{(p-1)^{3}}{p^{3}}.
            \]
        </div>

        <p>Now multiply the two pieces together:</p>
        <div class="math-display">
            \begin{align}
            \left(1-\frac{1}{(p-1)^{2}}\right)\left(1-\frac{1}{p}\right)^{3}
            &= \frac{p(p-2)}{(p-1)^{2}}\cdot\frac{(p-1)^{3}}{p^{3}} \\[6pt]
            &= \frac{p(p-2)(p-1)^{3}}{(p-1)^{2}p^{3}} \\
            &= \frac{(p-1)(p-2)}{p^{2}}.
            \end{align}
        </div>

        <p>But the right-hand side of the last displayed equality is exactly the single-prime factor that appears in the definition of \(N(p_{\max})\), namely \(\frac{(p-1)(p-2)}{p^{2}}\). Therefore the identity holds for each prime factor \(p\ge 3\). Taking the product of these equalities over all primes \(p\) with \(3\le p\le p_{\max}\) yields the claimed finite identity</p>
        <div class="math-display">
            \[
            N(p_{\max}) = C_{2}(p_{\max})\,[M_{\neq 2}(p_{\max})]^{3}.
            \]
        </div>
        <p>This completes the proof.</p>
        <div class="qed">∎</div>
    </div>

    <h2>Alternative display with the multiplicative constant \(\frac{1}{4}\)</h2>
    <p>Some presentations display the same algebra in the (equivalently true) form</p>
    <div class="math-display">
        \[
        \frac{N(p_{\max})}{\frac{1}{4}\,C_{2}(p_{\max})\,[M_{\neq 2}(p_{\max})]^{3}}=4,
        \]
    </div>
    <p>which follows immediately because \(C_{2}(p_{\max})[M_{\neq 2}(p_{\max})]^{3}=N(p_{\max})\) and hence the denominator equals \(\frac{1}{4}N(p_{\max})\), so the whole fraction equals \(N(p_{\max})/(\frac14 N(p_{\max}))=4\). Both formulations express the same algebraic fact: the per-prime factors match exactly.</p>

    <h2>Explicit numerical examples (step-by-step arithmetic)</h2>
    <p>We display the arithmetic with no omissions for the small cutoffs \(p_{\max}=3\), \(p_{\max}=5\), and \(p_{\max}=13\). Each example lists the left-hand product factor by factor, the right-hand product factor by factor, and the final equality. We simplify rational fractions fully where convenient and show decimal approximations for sanity checks.</p>

    <h3>Example: \(p_{\max}=3\)</h3>
    <div class="example-section">
        <div class="example-title">Primes used: \(\{3\}\).</div>
        
        <p><strong>Left-hand product:</strong></p>
        <div class="math-display">
            \[
            N(3) = \frac{(3-1)(3-2)}{3^{2}} = \frac{2\cdot 1}{9} = \frac{2}{9}.
            \]
        </div>

        <p><strong>Right-hand pieces:</strong></p>
        <div class="math-display">
            \[
            C_{2}(3)= 1-\frac{1}{(3-1)^{2}}=1-\frac{1}{4}=\frac{3}{4},
            \qquad
            M_{\neq 2}(3)=1-\frac{1}{3}=\frac{2}{3}.
            \]
        </div>
        <p>Then</p>
        <div class="math-display">
            \[
            C_{2}(3)\,[M_{\neq 2}(3)]^{3}
            = \frac{3}{4}\cdot\left(\frac{2}{3}\right)^{3}
            = \frac{3}{4}\cdot\frac{8}{27}
            = \frac{24}{108}
            = \frac{2}{9}.
            \]
        </div>
        <p>Hence \(N(3)=C_{2}(3)[M_{\neq2}(3)]^{3}=\frac{2}{9}\). Decimal check: \(2/9\approx 0.222222\).</p>
    </div>

    <h3>Example: \(p_{\max}=5\)</h3>
    <div class="example-section">
        <div class="example-title">Primes used: \(\{3,5\}\).</div>
        
        <p><strong>Left-hand product:</strong></p>
        <div class="math-display">
            \begin{align}
            N(5) &= \frac{(3-1)(3-2)}{3^{2}}\cdot\frac{(5-1)(5-2)}{5^{2}} \\
            &= \frac{2}{9}\cdot\frac{12}{25} \\
            &= \frac{24}{225} = \frac{8}{75}.
            \end{align}
        </div>

        <p><strong>Right-hand pieces:</strong></p>
        <div class="math-display">
            \begin{align}
            C_{2}(5) &= \left(1-\frac{1}{(3-1)^{2}}\right)\left(1-\frac{1}{(5-1)^{2}}\right)
            = \frac{3}{4}\cdot\frac{15}{16}=\frac{45}{64},\\[6pt]
            M_{\neq 2}(5) &= \left(1-\frac{1}{3}\right)\left(1-\frac{1}{5}\right)=\frac{2}{3}\cdot\frac{4}{5}=\frac{8}{15}.
            \end{align}
        </div>
        <p>Then</p>
        <div class="math-display">
            \[
            C_{2}(5)\,[M_{\neq 2}(5)]^{3}
            = \frac{45}{64}\cdot\left(\frac{8}{15}\right)^{3}
            = \frac{45}{64}\cdot\frac{512}{3375}.
            \]
        </div>
        <p>Simplify step by step:</p>
        <div class="math-display">
            \[
            \frac{45}{64}\cdot\frac{512}{3375}
            = \frac{45\cdot 512}{64\cdot 3375}
            = \frac{45\cdot 8}{3375}
            = \frac{360}{3375}
            = \frac{8}{75}.
            \]
        </div>
        <p>Hence \(N(5)=C_{2}(5)[M_{\neq 2}(5)]^{3}=\frac{8}{75}\). Decimal check: \(8/75\approx 0.106666\).</p>
    </div>

    <h3>Example: \(p_{\max}=13\)</h3>
    <div class="example-section">
        <div class="example-title">Primes used: \(\{3,5,7,11,13\}\).</div>
        
        <p><strong>Left-hand product</strong> (compute factor-by-factor):</p>
        <div class="math-display">
            \begin{align}
            N(13) &=
            \frac{(3-1)(3-2)}{3^{2}}
            \cdot
            \frac{(5-1)(5-2)}{5^{2}}
            \cdot
            \frac{(7-1)(7-2)}{7^{2}}
            \cdot
            \frac{(11-1)(11-2)}{11^{2}}
            \cdot
            \frac{(13-1)(13-2)}{13^{2}} \\
            &=
            \frac{2}{9}\cdot\frac{12}{25}\cdot\frac{30}{49}\cdot\frac{90}{121}\cdot\frac{132}{169}.
            \end{align}
        </div>
        <p>Multiplying numerators and denominators gives</p>
        <div class="math-display">
            \[
            N(13)=\frac{2\cdot 12\cdot 30\cdot 90\cdot 132}{9\cdot 25\cdot 49\cdot 121\cdot 169}
            =\frac{8\,553\,600}{225\,450\,225}.
            \]
        </div>
        <p>A convenient simplified representation (divide numerator and denominator by \(11\)) is</p>
        <div class="math-display">
            \[
            N(13)=\frac{3\,456}{91\,091}
            \approx 0.0379400819.
            \]
        </div>

        <p><strong>Right-hand pieces:</strong></p>
        <div class="math-display">
            \begin{align}
            C_{2}(13) &= \prod_{p\in\{3,5,7,11,13\}}\left(1-\frac{1}{(p-1)^{2}}\right)
            = \frac{11011}{16384}
            \approx 0.6720581055,\\[6pt]
            M_{\neq 2}(13) &= \prod_{p\in\{3,5,7,11,13\}}\left(1-\frac{1}{p}\right)
            = \frac{384}{1001}
            \approx 0.3836163836.
            \end{align}
        </div>
        <p>Compute the cube and the product:</p>
        <div class="math-display">
            \[
            [M_{\neq 2}(13)]^{3} = \left(\frac{384}{1001}\right)^{3},
            \qquad
            C_{2}(13)\,[M_{\neq 2}(13)]^{3} \;=\; N(13).
            \]
        </div>
        <p>The equality \(C_{2}(13)[M_{\neq 2}(13)]^{3}=N(13)\) holds exactly by the per-prime algebra proved above; the displayed rational values numerically match the left side and the right side to the shown decimal precision.</p>
    </div>

    <h2>Remarks and clarifications</h2>
    <ol>
        <li><strong>Why start at the prime \(3\) and not at \(2\).</strong> The left-hand factor for \(p=2\) would be \(\frac{(2-1)(2-2)}{2^{2}}=0\). Including \(p=2\) in the product would collapse \(N(p_{\max})\) to zero and destroy the identity. The algebraic identity that produces the factorization is valid prime-by-prime only for primes \(p\ge 3\); therefore the convention is to start all products at \(p=3\).</li>
        <li><strong>This is a prime-indexed identity.</strong> The index set must be the primes; attempting to replace the prime index by "all integers" or by a set that includes composite numbers will not preserve the algebra, because the factor \(\frac{(n-1)(n-2)}{n^{2}}\) for a composite \(n\) does not decompose in the same form and the sieve interpretation breaks down.</li>
        <li><strong>The \(\frac{1}{4}\) and the number \(4\) in some displays.</strong> If one writes the denominator as \(\frac{1}{4}\,C_{2}(p_{\max})[M_{\neq 2}(p_{\max})]^{3}\), then the quotient equals \(4\) because that denominator equals \(\frac{1}{4}N(p_{\max})\). The appearance of \(\frac{1}{4}\) is a harmless normalization: it does not change the substance of the identity.</li>
    </ol>

    <h2>Interpretation and implications for the twin prime problem</h2>
    <div class="interpretation">
        <div class="paragraph-title">What the identity means in words.</div>
        <p>The left-hand product \(N(p_{\max})\) is a finite sieve factor that quantifies how many integers remain after removing residues forbidden by divisibility conditions at primes up to \(p_{\max}\) for the twin prime pattern \((n,n+2)\). The right-hand side decomposes the same finite sieve factor into two conceptually distinct parts:</p>
        <ul>
            <li>\(M_{\neq 2}(p_{\max})\), which is a truncated Mertens-type product measuring <em>ordinary prime scarcity</em> (the density effect of primes), and</li>
            <li>\(C_{2}(p_{\max})\), which is the truncated Hardy–Littlewood twin-prime residue correction that accounts specifically for the residues excluded by the twin configuration.</li>
        </ul>
        <p>The identity says, exactly and at each finite cutoff, that the twin-prime sieve factor equals the cube of the ordinary prime-density factor multiplied by the twin-specific correction.</p>

        <div class="paragraph-title">Why the cube appears.</div>
        <p>Informally, twin primes require two numbers to be prime simultaneously (the number \(n\) and the number \(n+2\)). The appearance of the cube \([M_{\neq 2}(p_{\max})]^{3}\) can be interpreted as three overlapping density factors: two corresponding to prime-likeness of the separate entries \(n\) and \(n+2\), and a third that accounts for the mutual compatibility of their residues. The precise per-prime algebra above explains how those three factors combine multiplicatively into the simple polynomial factor \(\frac{(p-1)(p-2)}{p^{2}}\).</p>

        <div class="paragraph-title">What this does not do.</div>
        <p>This algebraic identity is an exact structural decomposition of finite cutoff sieve factors. It does not by itself prove that there are infinitely many twin primes. It clarifies the finite structure and shows compatibility between Hardy–Littlewood style factors and the concrete per-prime sieve factors that occur in modular/computational sieves.</p>
    </div>

    <h2>Connections to a modular sieve perspective</h2>
    <p>If one constructs a modular sieve that retains residue classes modulo a base modulus \(M\) (for example \(M=30\cdot 2^{n}\) as in your modular sieve program), then the finite products above are the natural multiplicative densities that appear when counting admissible residue classes modulo primes dividing \(M\) and when lifting to larger moduli. The exact finite factorization gives a direct algebraic link between the classical truncated constants used in the Hardy–Littlewood heuristic and the residue-counting factors that arise in explicit modular sieves.</p>

    <h2>Concluding statement</h2>
    <p>All steps of the algebra are elementary and exact. When the products are taken over primes \(p\) with \(3\le p\le p_{\max}\) the factor-by-factor algebraic identity</p>
    <div class="math-display">
        \[
        \left(1-\frac{1}{(p-1)^{2}}\right)\left(1-\frac{1}{p}\right)^{3}=\frac{(p-1)(p-2)}{p^{2}}
        \]
    </div>
    <p>immediately implies the global finite identity</p>
    <div class="math-display">
        \[
        \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}} \frac{(p-1)(p-2)}{p^{2}}
        =
        \left( \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}} \left(1-\frac{1}{(p-1)^{2}}\right) \right)
        \left( \prod_{\substack{p\ \text{prime}\\ 3\le p\le p_{\max}}} \left(1-\frac{1}{p}\right) \right)^{3}.
        \]
    </div>
    <p>This equality is exact for every finite cutoff \(p_{\max}\ge 3\), and the document above shows the algebra and numerical checks with no abbreviations.</p>

    <script>
        // Helper function to check if a number is prime
        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }
        
        // Get all primes up to n
        function getPrimesUpTo(n) {
            const primes = [];
            for (let i = 3; i <= n; i++) {
                if (isPrime(i)) primes.push(i);
            }
            return primes;
        }
        
        // Calculate greatest common divisor
        function gcd(a, b) {
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
        
        // Simplify a fraction
        function simplifyFraction(num, den) {
            const g = gcd(Math.abs(num), Math.abs(den));
            return [num / g, den / g];
        }
        
        function calculateIdentity() {
            const pmax = parseInt(document.getElementById('pmax-input').value);
            
            if (!isPrime(pmax) || pmax < 3) {
                document.getElementById('results').innerHTML = '<p style="color: red;">Please enter a prime number ≥ 3</p>';
                return;
            }
            
            const primes = getPrimesUpTo(pmax);
            let results = `<h3>Calculation for p_max = ${pmax}</h3>`;
            results += `<p><strong>Primes used:</strong> {${primes.join(', ')}}</p>`;
            
            // Show per-prime factorization first
            results += `<div class="per-prime-work"><h4>Per-Prime Identity Verification</h4>`;
            results += `<p>For each prime p ≥ 3, we verify: \\(\\left(1-\\frac{1}{(p-1)^{2}}\\right)\\left(1-\\frac{1}{p}\\right)^{3} = \\frac{(p-1)(p-2)}{p^{2}}\\)</p>`;
            
            for (let p of primes) {
                results += `<div class="prime-calculation">`;
                results += `<h5>Prime p = ${p}:</h5>`;
                
                // Left side calculation
                const term1_num = (p-1)*(p-1) - 1;
                const term1_den = (p-1)*(p-1);
                const [t1_simp_num, t1_simp_den] = simplifyFraction(term1_num, term1_den);
                
                const term2_num = p - 1;
                const term2_den = p;
                const [t2_simp_num, t2_simp_den] = simplifyFraction(term2_num, term2_den);
                
                const term2_cubed_num = t2_simp_num ** 3;
                const term2_cubed_den = t2_simp_den ** 3;
                
                const left_product_num = t1_simp_num * term2_cubed_num;
                const left_product_den = t1_simp_den * term2_cubed_den;
                const [left_final_num, left_final_den] = simplifyFraction(left_product_num, left_product_den);
                
                // Right side calculation
                const right_num = (p-1) * (p-2);
                const right_den = p * p;
                const [right_final_num, right_final_den] = simplifyFraction(right_num, right_den);
                
                results += `<p>\\[1-\\frac{1}{(${p}-1)^{2}} = 1-\\frac{1}{${(p-1)*(p-1)}} = \\frac{${(p-1)*(p-1)}-1}{${(p-1)*(p-1)}} = \\frac{${term1_num}}{${term1_den}}`;
                if (t1_simp_num !== term1_num || t1_simp_den !== term1_den) {
                    results += ` = \\frac{${t1_simp_num}}{${t1_simp_den}}`;
                }
                results += `\\]</p>`;
                
                results += `<p>\\[1-\\frac{1}{${p}} = \\frac{${p}-1}{${p}} = \\frac{${term2_num}}{${term2_den}}`;
                if (t2_simp_num !== term2_num || t2_simp_den !== term2_den) {
                    results += ` = \\frac{${t2_simp_num}}{${t2_simp_den}}`;
                }
                results += `\\]</p>`;
                
                results += `<p>\\[\\left(1-\\frac{1}{${p}}\\right)^{3} = \\left(\\frac{${t2_simp_num}}{${t2_simp_den}}\\right)^{3} = \\frac{${term2_cubed_num}}{${term2_cubed_den}}\\]</p>`;
                
                results += `<p><strong>Left side product:</strong></p>`;
                results += `<p>\\[\\frac{${t1_simp_num}}{${t1_simp_den}} \\cdot \\frac{${term2_cubed_num}}{${term2_cubed_den}} = \\frac{${left_product_num}}{${left_product_den}}`;
                if (left_final_num !== left_product_num || left_final_den !== left_product_den) {
                    results += ` = \\frac{${left_final_num}}{${left_final_den}}`;
                }
                results += `\\]</p>`;
                
                results += `<p><strong>Right side:</strong></p>`;
                results += `<p>\\[\\frac{(${p}-1)(${p}-2)}{${p}^{2}} = \\frac{${right_num}}{${right_den}}`;
                if (right_final_num !== right_num || right_final_den !== right_den) {
                    results += ` = \\frac{${right_final_num}}{${right_final_den}}`;
                }
                results += `\\]</p>`;
                
                const matches = (left_final_num === right_final_num && left_final_den === right_final_den);
                results += `<p><strong>Verification:</strong> <span style="color: ${matches ? 'green' : 'red'}">`;
                results += `${matches ? '✓ Identity holds!' : '✗ Identity fails!'}`;
                results += `</span></p>`;
                results += `</div>`;
            }
            results += `</div>`;
            
            // Calculate N(p_max) - left side
            let N_num = 1, N_den = 1;
            let leftFactors = [];
            
            for (let p of primes) {
                const factor_num = (p - 1) * (p - 2);
                const factor_den = p * p;
                leftFactors.push(`\\frac{${factor_num}}{${factor_den}}`);
                N_num *= factor_num;
                N_den *= factor_den;
            }
            
            const [N_simplified_num, N_simplified_den] = simplifyFraction(N_num, N_den);
            
            // Calculate C_2(p_max)
            let C2_num = 1, C2_den = 1;
            let c2Factors = [];
            let c2FactorsExpanded = [];
            
            for (let p of primes) {
                const factor_num = (p - 1) * (p - 1) - 1;
                const factor_den = (p - 1) * (p - 1);
                c2Factors.push(`\\left(1-\\frac{1}{${(p-1)*(p-1)}}\\right)`);
                c2FactorsExpanded.push(`\\frac{${factor_num}}{${factor_den}}`);
                C2_num *= factor_num;
                C2_den *= factor_den;
            }
            
            const [C2_simplified_num, C2_simplified_den] = simplifyFraction(C2_num, C2_den);
            
            // Calculate M_≠2(p_max)
            let M_num = 1, M_den = 1;
            let mFactors = [];
            let mFactorsExpanded = [];
            
            for (let p of primes) {
                const factor_num = p - 1;
                const factor_den = p;
                mFactors.push(`\\left(1-\\frac{1}{${p}}\\right)`);
                mFactorsExpanded.push(`\\frac{${factor_num}}{${factor_den}}`);
                M_num *= factor_num;
                M_den *= factor_den;
            }
            
            const [M_simplified_num, M_simplified_den] = simplifyFraction(M_num, M_den);
            
            // Calculate M^3
            const M3_num = M_simplified_num ** 3;
            const M3_den = M_simplified_den ** 3;
            
            // Calculate C_2 * M^3
            const right_num = C2_simplified_num * M3_num;
            const right_den = C2_simplified_den * M3_den;
            const [right_simplified_num, right_simplified_den] = simplifyFraction(right_num, right_den);
            
            results += `
                <div class="calculation-step">
                    <h4>Left-hand side: N(${pmax})</h4>
                    <p>\\[N(${pmax}) = ${leftFactors.join(' \\cdot ')}\\]</p>
                    <p>\\[= \\frac{${N_num}}{${N_den}} = \\frac{${N_simplified_num}}{${N_simplified_den}}\\]</p>
                    <p><strong>Decimal:</strong> ${(N_simplified_num / N_simplified_den).toFixed(10)}</p>
                </div>
                
                <div class="calculation-step">
                    <h4>Right-hand side components:</h4>
                    <p><strong>C₂ term:</strong></p>
                    <p>\\[C_2(${pmax}) = ${c2Factors.join(' \\cdot ')}\\]</p>
                    <p>\\[= ${c2FactorsExpanded.join(' \\cdot ')} = \\frac{${C2_num}}{${C2_den}} = \\frac{${C2_simplified_num}}{${C2_simplified_den}}\\]</p>
                    
                    <p><strong>M≠2 term:</strong></p>
                    <p>\\[M_{\\neq 2}(${pmax}) = ${mFactors.join(' \\cdot ')}\\]</p>
                    <p>\\[= ${mFactorsExpanded.join(' \\cdot ')} = \\frac{${M_num}}{${M_den}} = \\frac{${M_simplified_num}}{${M_simplified_den}}\\]</p>
                    
                    <p><strong>Cubed term:</strong></p>
                    <p>\\[[M_{\\neq 2}(${pmax})]^3 = \\left(\\frac{${M_simplified_num}}{${M_simplified_den}}\\right)^3 = \\frac{${M3_num}}{${M3_den}}\\]</p>
                </div>
                
                <div class="calculation-step">
                    <h4>Right-hand side product:</h4>
                    <p>\\[C_2(${pmax}) \\cdot [M_{\\neq 2}(${pmax})]^3 = \\frac{${C2_simplified_num}}{${C2_simplified_den}} \\cdot \\frac{${M3_num}}{${M3_den}}\\]</p>
                    <p>\\[= \\frac{${C2_simplified_num} \\cdot ${M3_num}}{${C2_simplified_den} \\cdot ${M3_den}} = \\frac{${right_num}}{${right_den}} = \\frac{${right_simplified_num}}{${right_simplified_den}}\\]</p>
                    <p><strong>Decimal:</strong> ${(right_simplified_num / right_simplified_den).toFixed(10)}</p>
                </div>
                
                <div class="verification">
                    <h4>Final Verification:</h4>
                    <p><strong>Left side:</strong> \\(N(${pmax}) = \\frac{${N_simplified_num}}{${N_simplified_den}}\\)</p>
                    <p><strong>Right side:</strong> \\(C_2(${pmax}) \\cdot [M_{\\neq 2}(${pmax})]^3 = \\frac{${right_simplified_num}}{${right_simplified_den}}\\)</p>
                    <p><strong>Identity holds?</strong> <span style="color: ${N_simplified_num === right_simplified_num && N_simplified_den === right_simplified_den ? 'green' : 'red'}; font-size: 18px; font-weight: bold;">
                        ${N_simplified_num === right_simplified_num && N_simplified_den === right_simplified_den ? '✓ YES' : '✗ NO'}
                    </span></p>
                </div>
            `;
            
            document.getElementById('results').innerHTML = results;
            
            // Re-render MathJax
            if (window.MathJax) {
                MathJax.typesetPromise([document.getElementById('results')]);
            }
        }
    </script>
</body>
</html>
